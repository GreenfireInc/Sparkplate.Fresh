# GPG Deterministic Key Generation Completion Report

**Component:** `src/utils/deterministicGPG.ts`
**Date:** December 10, 2025
**Status:** ✅ COMPLETED

## Objective
Achieve 100% deterministic OpenPGP key pair generation (public/private keys and fingerprint) derived from a BIP-39 mnemonic phrase and derivation path. The same mnemonic must ALWAYS produce the exact same GPG key.

## Challenges Encountered

### 1. Non-Determinism in OpenPGP.js
Despite patching `crypto.getRandomValues` with a deterministic PRNG, generated keys were initially different every time.
*   **Root Cause 1 (Early Capture):** OpenPGP.js captured the reference to `crypto.getRandomValues` at **module load time**, before our patch was applied.
*   **Root Cause 2 (Native Bypass):** Even after fixing the load timing, OpenPGP.js preferred using the browser's native `crypto.subtle.generateKey` for Ed25519 keys. This native implementation uses internal, opaque randomness that ignores our JavaScript-level patches.

### 2. Dependency Issues
*   Attempts to use `@skunkteam/aes-siv` (WASM) failed due to environment incompatibilities (missing `TextDecoder`/`module` globals in browser context).
*   Attempts to use low-level `@openpgp/key-core` for manual key injection failed because the package was not easily installable/compatible with the current project structure.

### 3. "Sabotage" Crashes
*   Attempting to simply set `crypto.subtle.generateKey = undefined` caused OpenPGP.js to crash, as it expected the function to exist.

## The Solution Strategy

We implemented a robust "Selective Sabotage" approach that forces OpenPGP.js into a deterministic path without crashing it.

### 1. Deterministic PRNG
We implemented a `DeterministicSha256PRNG` class that:
*   Takes a 32-byte seed derived from the mnemonic/private key.
*   Uses a Double-SHA-256 counter mode construction (`SHA256(SHA256(seed || counter || domain))`).
*   Produces a cryptographically secure, 100% reproducible stream of bytes.

### 2. Dynamic Import (Fixing Early Capture)
We moved the `import * as openpgp` statement **inside** the generation function, ensuring it executes **after** we have patched `crypto.getRandomValues`.

### 3. Selective API Interception (Fixing Native Bypass)
We patched `crypto.subtle.generateKey` with a wrapper that:
*   Intercepts calls specifically for `Ed25519` algorithms.
*   Throws a `NotSupportedError` for these calls.
*   Passes all other calls to the original native implementation.

**Why this works:** When OpenPGP.js encounters the `NotSupportedError` for the native `generateKey` call, it gracefully falls back to its internal **pure JavaScript implementation** of Ed25519 key generation. This JS implementation relies on `crypto.getRandomValues` for entropy—which we have successfully patched with our deterministic PRNG.

## Verification Results

We verified the solution by generating keys from the same mnemonic 3 separate times across different sessions.

*   **Input Seed:** Identical in all runs.
*   **PRNG Output:** Identical byte sequences generated in all runs.
*   **Final GPG Fingerprints:**
    *   **BTC:** `C0 EC 33 DB...` (Identical across 3 runs)
    *   **LTC:** `BA 2E E6 76...` (Identical across 3 runs)
    *   **ETH:** `E0 B2 3C 58...` (Identical across 3 runs)
    *   All currencies produced consistent, reproducible keys.

## Conclusion
The system now successfully generates fully deterministic, standard-compliant OpenPGP keys derived from cryptocurrency seeds, without relying on fragile external WASM libraries or low-level dependency injection. The solution is robust and contained entirely within `src/utils/deterministicGPG.ts`.

