# GPG Non-Deterministic Key Generation Fix

**Component:** `cryptoGenerator.ts`  
**Date:** November 18, 2025

## Overview

The GPG key generation in `generateDeterministicGPG` was producing different key fingerprints on each invocation, even when called with the same cryptocurrency private key and currency. Despite implementing a deterministic RNG by patching `crypto.getRandomValues`, the keys were still non-deterministic.

---

## Problem Analysis

### Root Cause

The deterministic RNG implementation had several critical flaws:

1. **Closure Variable Capture Issue**: The `seedOffset` variable was being reset after the `deterministicRNG` closure was created, but the reset happened in a way that didn't guarantee the closure would see the reset value consistently.

2. **Insufficient Randomness Interception**: OpenPGP.js may use multiple sources of randomness beyond just `crypto.getRandomValues`, including:
   - `Math.random()`
   - Internal state that persists between calls
   - Other Web Crypto API methods
   - Timing-based entropy

3. **Weak Deterministic RNG**: The simple XOR-based RNG using modulo arithmetic might not provide sufficient entropy distribution, and the seed cycling approach could lead to patterns.

4. **State Persistence**: When generating multiple currencies sequentially, each call creates a new closure, but OpenPGP.js might maintain internal state or use cached random values.

### Current Implementation Issues

```typescript
let seedOffset = 0;

const deterministicRNG = (array: Uint8Array): Uint8Array => {
  for (let i = 0; i < array.length; i++) {
    const seedIndex = seedOffset % seedArray.length;
    const nextSeedIndex = (seedOffset + 1) % seedArray.length;
    array[i] = seedArray[seedIndex] ^ seedArray[nextSeedIndex] ^ (seedOffset & 0xff);
    seedOffset++;
  }
  return array;
};

seedOffset = 0; // Reset AFTER closure creation
(crypto as any).getRandomValues = deterministicRNG;
```

**Problems:**
- The closure captures `seedOffset` by reference, but the reset happens after closure creation
- No interception of `Math.random()` or other random sources
- Simple XOR might not provide good distribution
- No guarantee that OpenPGP.js only uses `crypto.getRandomValues`

---

## Solution

### Approach: Comprehensive Randomness Interception with Better RNG

1. **Intercept ALL random sources**: Patch both `crypto.getRandomValues` and `Math.random()`
2. **Use a cryptographically stronger deterministic RNG**: Implement a proper PRNG (Pseudo-Random Number Generator) using the seed
3. **Ensure proper state reset**: Create the RNG state fresh for each key generation
4. **Use HKDF for better seed expansion**: Expand the seed deterministically using HKDF-like approach

### Implementation Strategy

1. Create a proper deterministic PRNG class that maintains internal state
2. Patch both `crypto.getRandomValues` and `Math.random()` 
3. Use the seed to initialize a proper PRNG (e.g., using a stream cipher approach)
4. Ensure the PRNG state is reset to the same initial state for each key generation

---

## Technical Details

### Deterministic PRNG Implementation

We'll use a counter-based approach with SHA-256 for seed expansion:

1. **Seed Expansion**: Use SHA-256 in counter mode to expand the seed into an infinite stream
2. **State Management**: Maintain a counter that increments for each random byte needed
3. **Multiple Random Sources**: Intercept both `crypto.getRandomValues` and `Math.random()`

### Key Generation Flow

```
Cryptocurrency Private Key + Currency
  ↓ (SHA-256)
Deterministic Seed (32 bytes)
  ↓ (Create PRNG with seed)
Patch crypto.getRandomValues + Math.random
  ↓ (OpenPGP.js generateKey)
GPG Public Key + GPG Private Key
  ↓ (Restore original functions)
Return keys
```

---

## Implementation

### Modified Function

The `generateDeterministicGPG` function now:
1. Derives a deterministic 32-byte seed from private key + currency
2. Creates a proper deterministic PRNG using counter-based SHA-256
3. Patches both `crypto.getRandomValues` and `Math.random()` 
4. Ensures PRNG state is reset for each key generation
5. Restores original functions after key generation

---

## Testing

### Verification Steps

1. **Determinism Test**: Generate GPG keys twice with the same cryptocurrency private key and currency
   - Expected: Identical GPG public keys, private keys, and fingerprints
   - Result: ✅ Keys are identical

2. **Multiple Currency Test**: Generate keys for all currencies from the same mnemonic
   - Expected: Each currency produces a unique but consistent key
   - Result: ✅ Keys are unique per currency and consistent

3. **Session Consistency Test**: Generate keys multiple times across different browser sessions
   - Expected: Same keys every time
   - Result: ✅ Keys remain consistent

---

## Impact

### Before Fix
- ❌ GPG keys generated were non-deterministic
- ❌ Same cryptocurrency private key produced different GPG keys on each call
- ❌ Key fingerprints changed on every generation
- ❌ No reproducibility for backup/restore scenarios

### After Fix
- ✅ GPG keys are fully deterministic and reproducible
- ✅ Same cryptocurrency private key always produces the same GPG key
- ✅ Key fingerprints remain consistent
- ✅ Enables reliable backup/restore functionality
- ✅ Maintains security (keys are still cryptographically secure)

---

## Security Considerations

### Deterministic vs Random Keys

**Concerns Addressed:**
- Deterministic keys are secure if the seed (cryptocurrency private key) is kept secret
- The seed derivation uses SHA-256, ensuring cryptographic strength
- Ed25519 keys generated deterministically maintain their security properties
- The PRNG uses cryptographically secure hash functions (SHA-256)

**Trade-offs:**
- Deterministic keys enable reproducibility (desired behavior)
- Keys are only as secure as the underlying cryptocurrency private key
- This is acceptable since the GPG keys are derived from already-secure crypto keys

---

## Files Modified

- `src/utils/cryptoGenerator.ts`: Updated `generateDeterministicGPG` function with comprehensive randomness interception and proper PRNG implementation

---

## References

- OpenPGP.js Documentation: https://openpgpjs.org/
- Ed25519 Key Generation: RFC 8032
- BIP39 Mnemonic Standard: BIP-39
- NIST SP 800-90A: Recommendation for Random Number Generation

