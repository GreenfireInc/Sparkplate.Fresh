# GPG Still Non-Deterministic - Final Fix

**Component:** `cryptoGenerator.ts`  
**Date:** November 18, 2025

## Overview

Despite implementing a deterministic PRNG with comprehensive randomness interception, the GPG key generation is still producing different key fingerprints on each invocation. The previous fix had critical flaws in the buffer management logic.

---

## Problem Analysis

### Root Cause

The previous implementation had several critical issues:

1. **Async Buffer Refill During Key Generation**: 
   - Lines 164-181 contain logic to refill the buffer asynchronously while key generation is happening
   - This introduces race conditions where the buffer state can change unpredictably
   - The async refill resets `syncRandomOffset` to 0, potentially causing byte reuse

2. **Buffer Offset Reset**: 
   - Line 175: `syncRandomOffset = 0` in the refill logic causes the offset to reset
   - This can cause the same bytes to be read multiple times if the timing is wrong
   - Creates non-deterministic behavior depending on when the async promise resolves

3. **Complex Buffer Management**:
   - The code tries to be "smart" by refilling at 75% usage
   - This complexity introduces multiple code paths that can behave differently
   - Makes it harder to reason about determinism

4. **Insufficient Initial Buffer**:
   - 32KB might not be enough for all key generation operations
   - If the buffer runs out, an error is thrown, but the refill logic might kick in first

### Current Implementation Issues

```typescript
// Refill buffer asynchronously if we're running low
if (syncRandomOffset > syncRandomBuffer.length * 0.75 && remaining > 0) {
  if (!bufferPromise) {
    bufferPromise = (async () => {
      const newBytes = await prng.getNextBytes(4096);
      // Append to existing buffer if there's remaining data
      if (syncRandomOffset < syncRandomBuffer.length) {
        const remainingBuffer = syncRandomBuffer.subarray(syncRandomOffset);
        const combined = new Uint8Array(remainingBuffer.length + newBytes.length);
        combined.set(remainingBuffer);
        combined.set(newBytes, remainingBuffer.length);
        syncRandomBuffer = combined;
        syncRandomOffset = 0;  // ❌ This reset causes non-determinism!
      } else {
        syncRandomBuffer = newBytes;
        syncRandomOffset = 0;  // ❌ This reset causes non-determinism!
      }
      bufferPromise = null;
    })();
  }
}
```

**Problems:**
- Async operation modifies shared state during key generation
- Offset reset can cause bytes to be reused
- Race condition: buffer state changes unpredictably
- No guarantee of when the promise resolves relative to key generation

---

## Solution

### Approach: Simple Linear Buffer with No Refills

The solution is to dramatically simplify the implementation:

1. **Generate a very large buffer upfront**: Pre-generate enough bytes (e.g., 1MB) to handle all key generation operations
2. **Remove all async refill logic**: No runtime buffer refills, just linear reads
3. **Simple linear offset tracking**: Just increment the offset, never reset it
4. **Fail fast if exhausted**: If we run out of bytes, throw a clear error (shouldn't happen with 1MB)

### Implementation Strategy

1. Pre-generate 1MB (1,048,576 bytes) of deterministic random data
2. Use simple linear reads from this buffer
3. No async operations during key generation
4. No buffer modifications after initialization
5. Each call to `generateDeterministicGPG` creates a fresh buffer from counter = 0

---

## Technical Details

### Simplified Buffer Management

```typescript
// Pre-generate 1MB buffer - more than enough for any key generation
const syncRandomBuffer = await prng.getNextBytes(1048576);
let syncRandomOffset = 0;

// Simple linear read - no refills, no resets, no async operations
const syncGetRandomValues = (array: Uint8Array): Uint8Array => {
  if (syncRandomOffset + array.length > syncRandomBuffer.length) {
    throw new Error(`Ran out of pre-generated random bytes`);
  }
  
  array.set(syncRandomBuffer.subarray(syncRandomOffset, syncRandomOffset + array.length));
  syncRandomOffset += array.length;
  
  return array;
};
```

**Benefits:**
- No async operations during key generation
- No offset resets
- No buffer modifications
- Completely deterministic - same input always produces same output
- Simple and easy to reason about

### Key Generation Flow

```
Cryptocurrency Private Key + Currency
  ↓ (SHA-256)
Deterministic Seed (32 bytes)
  ↓ (Create PRNG with seed, counter = 0)
Pre-generate 1MB buffer
  ↓ (Patch crypto.getRandomValues + Math.random)
OpenPGP.js generateKey (reads linearly from buffer)
  ↓ (Restore original functions)
Return keys
```

---

## Implementation

### Modified Function

The `generateDeterministicGPG` function now:
1. Creates a fresh PRNG instance with counter = 0
2. Pre-generates 1MB of random bytes upfront
3. Uses simple linear reads with no refills or resets
4. Patches both `crypto.getRandomValues` and `Math.random()`
5. Restores original functions after key generation

### Key Changes

- Increased buffer size from 32KB to 1MB
- Removed all async buffer refill logic
- Simplified `syncGetRandomValues` to simple linear reads
- No offset resets - just linear increment
- No runtime buffer modifications

---

## Testing

### Verification Steps

1. **Determinism Test**: Generate GPG keys twice with the same inputs
   - Expected: Identical fingerprints
   - Result: ✅ Keys are identical

2. **Multiple Calls Test**: Generate keys 10 times in a row
   - Expected: Same fingerprint every time
   - Result: ✅ Consistent fingerprints

3. **Different Currency Test**: Generate keys for all currencies
   - Expected: Each currency has unique but consistent fingerprint
   - Result: ✅ Unique per currency, consistent across calls

---

## Impact

### Before Fix
- ❌ Async buffer refill caused race conditions
- ❌ Offset resets caused byte reuse
- ❌ Complex buffer management introduced non-determinism
- ❌ Different fingerprints on each call

### After Fix
- ✅ No async operations during key generation
- ✅ Simple linear buffer reads
- ✅ No offset resets or buffer modifications
- ✅ Same fingerprint every time
- ✅ Fully deterministic and reproducible

---

## Security Considerations

- Using 1MB of pre-generated random bytes is secure
- The PRNG is cryptographically secure (counter-based SHA-256)
- Linear reads ensure no byte reuse
- Deterministic keys are as secure as the seed (cryptocurrency private key)

---

## Files Modified

- `src/utils/cryptoGenerator.ts`: Simplified buffer management, removed async refill logic, increased buffer size to 1MB

---

## References

- Deterministic Key Generation: Best Practices
- Counter-based DRBG: NIST SP 800-90A
- OpenPGP.js Documentation: https://openpgpjs.org/

