# SQLite3 Database Implementation Methodology

**Date**: October 19, 2025  
**Component**: Database Layer Implementation  
**Author**: Corey  
**References**: `00.references/service/`, `src/components/pages/settings/UserProfile.vue`

## Executive Summary

This document outlines the methodology for implementing an SQLite3 database in Sparkplate to replace the current IndexedDB (JsStore) implementation. The goal is to enable persistent user profile storage with data collected from the User Settings interface, following the patterns established in the reference `UserService.js` and `IdbService.js` files.

## Problem Statement

Currently, Sparkplate lacks a persistent database layer for storing user profile information collected through the User Settings interface. The application needs:

1. A robust database solution for storing user profiles
2. CRUD operations for user management
3. Secure password handling with bcrypt
4. Settings management per user
5. Data persistence across application sessions

## Proposed Solution: SQLite3 Integration

### Why SQLite3?

SQLite3 is chosen over the reference's IndexedDB implementation for the following reasons:

1. **Native Integration**: Better suited for Electron applications
2. **Server-Side Support**: Can be used in both main and renderer processes
3. **Performance**: Superior performance for complex queries and large datasets
4. **Reliability**: ACID compliance and robust transaction support
5. **Portability**: Single file database that's easy to backup and migrate
6. **SQL Standard**: Standard SQL syntax instead of proprietary API

## Architecture Overview

### Database Structure

```
Sparkplate Database (sparkplate.db)
├── users (table)
├── user_settings (table)
└── migrations (table)
```

### Technology Stack

- **Database**: SQLite3
- **Node Driver**: `better-sqlite3` (synchronous, faster than `sqlite3`)
- **Password Hashing**: `bcryptjs`
- **Migration Management**: Custom migration system
- **Location**: `%APPDATA%/Sparkplate/sparkplate.db` (Windows) or equivalent for other OS

## Implementation Plan

### Phase 1: Setup and Configuration

#### 1.1 Install Dependencies

```bash
npm install better-sqlite3 bcryptjs
npm install --save-dev @types/better-sqlite3 @types/bcryptjs
```

#### 1.2 Create Database Service Layer

**File**: `src/services/database/DatabaseService.ts`

```typescript
import Database from 'better-sqlite3'
import path from 'path'
import { app } from 'electron'

export class DatabaseService {
  private db: Database.Database
  private static instance: DatabaseService

  private constructor() {
    const dbPath = path.join(app.getPath('userData'), 'sparkplate.db')
    this.db = new Database(dbPath)
    this.db.pragma('journal_mode = WAL') // Write-Ahead Logging for better performance
    this.initialize()
  }

  public static getInstance(): DatabaseService {
    if (!DatabaseService.instance) {
      DatabaseService.instance = new DatabaseService()
    }
    return DatabaseService.instance
  }

  private initialize(): void {
    this.createTables()
    this.runMigrations()
  }

  private createTables(): void {
    // Tables creation logic
  }

  public getDatabase(): Database.Database {
    return this.db
  }

  public close(): void {
    this.db.close()
  }
}
```

### Phase 2: Table Schema Design

#### 2.1 Users Table

Based on `UserProfile.vue` fields and `UserService.js` reference:

```sql
CREATE TABLE IF NOT EXISTS users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  email TEXT UNIQUE NOT NULL,
  password TEXT NOT NULL,
  firstName TEXT,
  lastName TEXT,
  company TEXT,
  website TEXT,
  bio TEXT,
  domains TEXT, -- JSON string of domains array
  twitter TEXT,
  instagram TEXT,
  linkedin TEXT,
  github TEXT,
  phone TEXT,
  createdAt DATETIME DEFAULT CURRENT_TIMESTAMP,
  updatedAt DATETIME DEFAULT CURRENT_TIMESTAMP
)
```

#### 2.2 User Settings Table

Based on `SettingsService.js` reference:

```sql
CREATE TABLE IF NOT EXISTS user_settings (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  userId INTEGER NOT NULL,
  language TEXT DEFAULT 'English',
  currency TEXT DEFAULT 'USD ($)',
  theme TEXT DEFAULT 'System',
  closeToTray BOOLEAN DEFAULT 0,
  blessedServer BOOLEAN DEFAULT 0,
  expressServer BOOLEAN DEFAULT 0,
  createdAt DATETIME DEFAULT CURRENT_TIMESTAMP,
  updatedAt DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (userId) REFERENCES users(id) ON DELETE CASCADE
)
```

#### 2.3 Migrations Table

```sql
CREATE TABLE IF NOT EXISTS migrations (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  version INTEGER UNIQUE NOT NULL,
  description TEXT,
  appliedAt DATETIME DEFAULT CURRENT_TIMESTAMP
)
```

### Phase 3: Service Layer Implementation

#### 3.1 User Service

**File**: `src/services/database/UserService.ts`

Implements the following methods (based on reference `UserService.js`):

```typescript
export class UserService {
  private db: Database.Database

  constructor(database: DatabaseService) {
    this.db = database.getDatabase()
  }

  // Core CRUD Operations
  async getUsers(): Promise<User[]>
  async getUserById(id: number): Promise<User | null>
  async getUserByEmail(email: string): Promise<User | null>
  async addUser(user: CreateUserDto): Promise<User | null>
  async updateUser(id: number, user: UpdateUserDto): Promise<number>
  async removeUser(id: number): Promise<number>
  
  // Authentication
  async login(email: string, password: string): Promise<User | null>
  async updatePassword(id: number, newPassword: string): Promise<number>
  
  // Utility
  private sanitize(user: any): User
  private hashPassword(password: string): string
  private comparePassword(password: string, hash: string): boolean
}
```

Key Implementation Details:

1. **Email Normalization**: Always convert emails to lowercase
2. **Password Hashing**: Use bcrypt with salt rounds of 10
3. **Duplicate Prevention**: Check for existing email before insert
4. **Data Sanitization**: Remove password from returned user objects
5. **Transaction Support**: Use transactions for critical operations

#### 3.2 Settings Service

**File**: `src/services/database/SettingsService.ts`

Implements the following methods (based on reference `SettingsService.js`):

```typescript
export class SettingsService {
  private db: Database.Database

  constructor(database: DatabaseService) {
    this.db = database.getDatabase()
  }

  async getUserSettings(userId: number): Promise<UserSettings | null>
  async addUserSettings(userId: number, settings: SettingsDto): Promise<number>
  async updateUserSettings(userId: number, settings: Partial<SettingsDto>): Promise<number>
  async removeUserSettings(userId: number): Promise<number>
}
```

### Phase 4: Integration with User Profile Component

#### 4.1 IPC Communication

**File**: `background/main/index.ts`

Set up IPC handlers for database operations:

```typescript
import { ipcMain } from 'electron'
import { DatabaseService } from '@/services/database/DatabaseService'
import { UserService } from '@/services/database/UserService'
import { SettingsService } from '@/services/database/SettingsService'

// Initialize services
const dbService = DatabaseService.getInstance()
const userService = new UserService(dbService)
const settingsService = new SettingsService(dbService)

// User operations
ipcMain.handle('db:user:create', async (_, userData) => {
  return await userService.addUser(userData)
})

ipcMain.handle('db:user:update', async (_, id, userData) => {
  return await userService.updateUser(id, userData)
})

ipcMain.handle('db:user:get', async (_, id) => {
  return await userService.getUserById(id)
})

// Settings operations
ipcMain.handle('db:settings:get', async (_, userId) => {
  return await settingsService.getUserSettings(userId)
})

ipcMain.handle('db:settings:update', async (_, userId, settings) => {
  return await settingsService.updateUserSettings(userId, settings)
})
```

#### 4.2 Preload Script

**File**: `background/preload/index.ts`

Expose database API to renderer:

```typescript
import { contextBridge, ipcRenderer } from 'electron'

contextBridge.exposeInMainWorld('database', {
  user: {
    create: (userData: any) => ipcRenderer.invoke('db:user:create', userData),
    update: (id: number, userData: any) => ipcRenderer.invoke('db:user:update', id, userData),
    get: (id: number) => ipcRenderer.invoke('db:user:get', id),
  },
  settings: {
    get: (userId: number) => ipcRenderer.invoke('db:settings:get', userId),
    update: (userId: number, settings: any) => ipcRenderer.invoke('db:settings:update', userId, settings),
  }
})
```

#### 4.3 Update UserProfile Component

**File**: `src/components/pages/settings/UserProfile.vue`

Add database integration to existing component:

```typescript
import { ref, onMounted } from 'vue'
import { useAuth } from '@/composables/useAuth'

export default {
  setup() {
    const { currentUser } = useAuth()
    const profile = ref({
      firstName: '',
      lastName: '',
      company: '',
      email: '',
      domains: '',
      language: '',
      currency: '',
      twitter: '',
      instagram: '',
      linkedin: '',
      github: '',
      website: '',
      bio: ''
    })

    onMounted(async () => {
      if (currentUser.value?.id) {
        const userData = await window.database.user.get(currentUser.value.id)
        if (userData) {
          Object.assign(profile.value, userData)
        }
      }
    })

    const saveChanges = async () => {
      try {
        if (currentUser.value?.id) {
          await window.database.user.update(currentUser.value.id, profile.value)
          // Show success notification
        }
      } catch (error) {
        console.error('Failed to save user profile:', error)
        // Show error notification
      }
    }

    return {
      profile,
      saveChanges
    }
  }
}
```

#### 4.4 Update ApplicationSettings Component

**File**: `src/components/pages/settings/ApplicationSettings.vue`

Add settings persistence:

```typescript
import { ref, onMounted } from 'vue'
import { useAuth } from '@/composables/useAuth'

export default {
  setup() {
    const { currentUser } = useAuth()
    const closeToTray = ref(false)
    const blessedServer = ref(false)
    const expressServer = ref(false)
    const theme = ref('System')
    const language = ref('English')

    onMounted(async () => {
      if (currentUser.value?.id) {
        const settings = await window.database.settings.get(currentUser.value.id)
        if (settings) {
          closeToTray.value = settings.closeToTray
          blessedServer.value = settings.blessedServer
          expressServer.value = settings.expressServer
          theme.value = settings.theme
          language.value = settings.language
        }
      }
    })

    const saveSettings = async () => {
      try {
        if (currentUser.value?.id) {
          await window.database.settings.update(currentUser.value.id, {
            closeToTray: closeToTray.value,
            blessedServer: blessedServer.value,
            expressServer: expressServer.value,
            theme: theme.value,
            language: language.value
          })
        }
      } catch (error) {
        console.error('Failed to save settings:', error)
      }
    }

    return {
      closeToTray,
      blessedServer,
      expressServer,
      theme,
      language,
      saveSettings
    }
  }
}
```

### Phase 5: Migration System

#### 5.1 Migration Manager

**File**: `src/services/database/MigrationManager.ts`

```typescript
export class MigrationManager {
  private db: Database.Database

  constructor(database: DatabaseService) {
    this.db = database.getDatabase()
  }

  getCurrentVersion(): number {
    const result = this.db.prepare(
      'SELECT MAX(version) as version FROM migrations'
    ).get()
    return result?.version || 0
  }

  applyMigration(version: number, description: string, sql: string): void {
    const transaction = this.db.transaction(() => {
      this.db.exec(sql)
      this.db.prepare(
        'INSERT INTO migrations (version, description) VALUES (?, ?)'
      ).run(version, description)
    })
    transaction()
  }

  runMigrations(): void {
    const currentVersion = this.getCurrentVersion()
    const migrations = this.getMigrations()
    
    migrations
      .filter(m => m.version > currentVersion)
      .forEach(migration => {
        console.log(`Applying migration ${migration.version}: ${migration.description}`)
        this.applyMigration(migration.version, migration.description, migration.sql)
      })
  }

  private getMigrations(): Migration[] {
    return [
      {
        version: 1,
        description: 'Initial schema',
        sql: `
          CREATE TABLE IF NOT EXISTS users (...);
          CREATE TABLE IF NOT EXISTS user_settings (...);
        `
      },
      // Future migrations go here
    ]
  }
}
```

### Phase 6: Type Definitions

**File**: `src/types/database.d.ts`

```typescript
export interface User {
  id: number
  email: string
  firstName: string | null
  lastName: string | null
  company: string | null
  website: string | null
  bio: string | null
  domains: string | null
  twitter: string | null
  instagram: string | null
  linkedin: string | null
  github: string | null
  phone: string | null
  createdAt: string
  updatedAt: string
}

export interface CreateUserDto {
  email: string
  password: string
  firstName?: string
  lastName?: string
}

export interface UpdateUserDto {
  firstName?: string
  lastName?: string
  company?: string
  email?: string
  website?: string
  bio?: string
  domains?: string
  twitter?: string
  instagram?: string
  linkedin?: string
  github?: string
  phone?: string
}

export interface UserSettings {
  id: number
  userId: number
  language: string
  currency: string
  theme: string
  closeToTray: boolean
  blessedServer: boolean
  expressServer: boolean
  createdAt: string
  updatedAt: string
}

export interface SettingsDto {
  language?: string
  currency?: string
  theme?: string
  closeToTray?: boolean
  blessedServer?: boolean
  expressServer?: boolean
}

declare global {
  interface Window {
    database: {
      user: {
        create: (userData: CreateUserDto) => Promise<User | null>
        update: (id: number, userData: UpdateUserDto) => Promise<number>
        get: (id: number) => Promise<User | null>
      }
      settings: {
        get: (userId: number) => Promise<UserSettings | null>
        update: (userId: number, settings: SettingsDto) => Promise<number>
      }
    }
  }
}
```

## Security Considerations

### 1. Password Security

- **Hashing**: Use bcrypt with salt rounds of 10 (minimum)
- **Never Log Passwords**: Ensure passwords are never logged or exposed
- **Sanitization**: Always remove password field from returned user objects

### 2. SQL Injection Prevention

- **Prepared Statements**: Always use prepared statements with parameter binding
- **Input Validation**: Validate all user input before database operations
- **Type Safety**: Use TypeScript for compile-time type checking

### 3. Database File Security

- **Location**: Store in user data directory with appropriate permissions
- **Encryption**: Consider encrypting sensitive fields at rest
- **Backup**: Implement regular backup strategy

## Testing Strategy

### Unit Tests

1. **UserService Tests**
   - Test user creation with duplicate email
   - Test password hashing and verification
   - Test data sanitization
   - Test user updates and deletions

2. **SettingsService Tests**
   - Test settings creation
   - Test settings updates
   - Test foreign key constraints

3. **Migration Tests**
   - Test migration application
   - Test migration rollback scenarios

### Integration Tests

1. **IPC Communication**
   - Test main-to-renderer communication
   - Test error handling
   - Test concurrent operations

2. **Component Integration**
   - Test UserProfile save functionality
   - Test settings persistence
   - Test data loading on mount

## Migration from IndexedDB (If Applicable)

If migrating from an existing IndexedDB implementation:

### Migration Strategy

1. **Export Data**: Create export utility to dump existing data
2. **Transform Data**: Convert data format to match new schema
3. **Import Data**: Import transformed data into SQLite
4. **Verification**: Verify data integrity post-migration
5. **Cleanup**: Remove old IndexedDB instance

### Migration Utility

**File**: `src/services/database/migrations/IdbToSqliteMigration.ts`

```typescript
export class IdbToSqliteMigration {
  async migrate(): Promise<void> {
    // 1. Export from IndexedDB
    const idbData = await this.exportFromIndexedDb()
    
    // 2. Transform data
    const transformedData = this.transformData(idbData)
    
    // 3. Import to SQLite
    await this.importToSqlite(transformedData)
    
    // 4. Verify
    const isValid = await this.verifyMigration()
    
    if (isValid) {
      // 5. Cleanup
      await this.cleanupIndexedDb()
    }
  }
}
```

## Performance Optimization

### 1. Indexing Strategy

```sql
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_user_settings_userId ON user_settings(userId);
```

### 2. Query Optimization

- Use prepared statements (cached)
- Batch operations where possible
- Use transactions for multiple writes
- Enable WAL mode for better concurrency

### 3. Connection Pooling

For main process, use singleton pattern to maintain single connection.

## Monitoring and Logging

### Database Operations Logging

```typescript
class DatabaseLogger {
  logQuery(sql: string, params: any[], duration: number): void {
    if (process.env.NODE_ENV === 'development') {
      console.log(`[DB] ${sql} [${duration}ms]`, params)
    }
  }

  logError(operation: string, error: Error): void {
    console.error(`[DB Error] ${operation}:`, error)
  }
}
```

## Rollback Strategy

### Database Backup

```typescript
class DatabaseBackupService {
  async createBackup(): Promise<string> {
    const timestamp = Date.now()
    const backupPath = path.join(
      app.getPath('userData'),
      `backups/sparkplate_${timestamp}.db`
    )
    await fs.copyFile(dbPath, backupPath)
    return backupPath
  }

  async restoreBackup(backupPath: string): Promise<void> {
    await fs.copyFile(backupPath, dbPath)
  }
}
```

## Benefits of This Approach

1. **Performance**: SQLite3 is significantly faster than IndexedDB for complex queries
2. **Reliability**: ACID compliance ensures data integrity
3. **Portability**: Single file database is easy to backup and migrate
4. **Standards**: Uses standard SQL syntax
5. **Maturity**: Well-tested and widely used in Electron apps
6. **Scalability**: Can handle larger datasets efficiently
7. **Developer Experience**: Better debugging tools and query inspection

## Potential Challenges

1. **Learning Curve**: Team needs to learn SQLite3 and better-sqlite3 API
2. **Migration Complexity**: If migrating from existing system
3. **Platform Differences**: Need to test on Windows, macOS, and Linux
4. **Binary Dependencies**: better-sqlite3 requires native compilation

## Alternative Considerations

### Why Not Stay with IndexedDB?

- Limited query capabilities
- Asynchronous-only API can be cumbersome
- Browser-focused, not ideal for Electron
- Complex schema migrations

### Why Not Use Other Databases?

- **PostgreSQL/MySQL**: Overkill for desktop app, requires server
- **MongoDB**: No strong typing, complex setup
- **LevelDB**: Too low-level, no SQL

## Timeline Estimate

- **Phase 1 (Setup)**: 1-2 days
- **Phase 2 (Schema)**: 1 day
- **Phase 3 (Services)**: 3-4 days
- **Phase 4 (Integration)**: 2-3 days
- **Phase 5 (Migrations)**: 1-2 days
- **Phase 6 (Types)**: 1 day
- **Testing**: 2-3 days
- **Documentation**: 1 day

**Total Estimated Time**: 12-17 days

## Conclusion

Implementing SQLite3 provides a robust, performant, and maintainable database solution for Sparkplate. Following this methodology ensures a systematic approach to implementation, maintaining code quality and allowing for future scalability.

The integration with existing User Profile and Application Settings components will be seamless, providing users with persistent storage of their preferences and profile information.

## Next Steps

1. Review and approve methodology
2. Install dependencies and setup development environment
3. Implement DatabaseService and table schemas
4. Create UserService and SettingsService
5. Set up IPC communication layer
6. Integrate with UI components
7. Write comprehensive tests
8. Deploy and monitor

## References

- SQLite Documentation: https://www.sqlite.org/docs.html
- better-sqlite3: https://github.com/WiseLibs/better-sqlite3
- Electron Security: https://www.electronjs.org/docs/latest/tutorial/security
- bcryptjs: https://github.com/dcodeIO/bcrypt.js

