# Polkadot Import Method Switch Implementation Plan
**Date:** October 5, 2025  
**Issue:** Implement switchable import methods (Exodus vs Polkadot.js) for multiple input formats  
**Status:** üìã PLANNING

---

## üìã **Executive Summary**

This plan outlines the implementation of a flexible import system for Polkadot (DOT) that supports multiple import methods and input formats. The system will allow users to import wallets using either the Exodus wallet method or the official Polkadot.js method, with automatic format detection and manual override capabilities.

### **Supported Input Types:**
1. **Private Key** (64-character hex)
2. **Mnemonic Seed** (12/24-word BIP39 phrase)
3. **Keystore** (encrypted .keystore file)
4. **JSON** (plain unencrypted JSON file)

### **Import Methods:**
1. **Exodus Method** - Specific implementation used by Exodus wallet
2. **Polkadot.js Method** - Official standard using PKCS#8 + SR25519

---

## üéØ **Goals & Objectives**

### **Primary Goals:**
1. ‚úÖ Support both Exodus and Polkadot.js import methods
2. ‚úÖ Handle all four input types (privateKey, mnemonic, keystore, JSON)
3. ‚úÖ Automatic format detection with manual override option
4. ‚úÖ Maintain compatibility with existing export functionality
5. ‚úÖ Provide clear user feedback and error messages

### **Success Criteria:**
- ‚úÖ Import from Exodus-exported files works correctly
- ‚úÖ Import from Polkadot.js-exported keystores works correctly
- ‚úÖ Import from LoginStandard JSON exports works correctly
- ‚úÖ Private keys and mnemonics generate correct addresses
- ‚úÖ Users can manually select import method if auto-detection fails

---

## üîç **Method Comparison Analysis**

### **Exodus Method vs Polkadot.js Method**

| Aspect | Exodus Method | Polkadot.js Method |
|--------|--------------|-------------------|
| **Crypto Type** | May use Ed25519 or SR25519 | Standard SR25519 (configurable) |
| **Key Derivation** | Custom derivation path | Standard Polkadot derivation |
| **Address Format** | SS58 with specific prefix | SS58 with standard prefix (0) |
| **Keystore Encryption** | Standard PKCS#8 + scrypt | Standard PKCS#8 + scrypt |
| **Mnemonic Handling** | BIP39 with custom derivation | BIP39 with Polkadot derivation |
| **Private Key Format** | 64-char hex (may interpret differently) | 64-char hex as seed |

### **Key Technical Differences:**

#### **1. Address Generation from Private Key**
```typescript
// Exodus Method
// May treat private key as direct secret key
const exodusAddress = generateAddressExodus(privateKey);

// Polkadot.js Method
// Treats private key as seed for keypair generation
const polkadotAddress = generateAddressPolkadot(privateKey);
```

#### **2. Mnemonic to Private Key Derivation**
```typescript
// Exodus Method
// May use specific derivation path: m/44'/354'/0'/0'/0'
const exodusPrivateKey = deriveMnemonicExodus(mnemonic, path);

// Polkadot.js Method
// Uses standard Polkadot derivation: //polkadot
const polkadotPrivateKey = deriveMnemonicPolkadot(mnemonic);
```

#### **3. Keystore Decryption**
```typescript
// Both methods use same standard
// PKCS#8 + scrypt + xsalsa20-poly1305
// But may differ in how they interpret the decrypted key
```

---

## üìê **Architecture Design**

### **Component Structure**

```
src/components/currencies/ext.DOT.Polkadot/
‚îú‚îÄ‚îÄ DOT.Polkadot.Export.ts (‚úÖ EXISTS)
‚îú‚îÄ‚îÄ DOT.Polkadot.Import.ts (üìù NEW - Main import orchestrator)
‚îú‚îÄ‚îÄ DOT.Polkadot.Import.Exodus.ts (üìù NEW - Exodus-specific logic)
‚îú‚îÄ‚îÄ DOT.Polkadot.Import.PolkadotJs.ts (üìù NEW - Polkadot.js logic)
‚îú‚îÄ‚îÄ DOT.Polkadot.Import.Detect.ts (üìù NEW - Format detection)
‚îî‚îÄ‚îÄ DOT.Polkadot.Import.Types.ts (üìù NEW - Type definitions)
```

### **Data Flow**

```
User Input (privateKey/mnemonic/keystore/json)
    ‚Üì
Format Detection (Auto-detect or Manual Selection)
    ‚Üì
Method Selection (Exodus or Polkadot.js)
    ‚Üì
Import Processing (Method-specific logic)
    ‚Üì
Validation & Address Generation
    ‚Üì
Account Creation in LoginStandard
```

---

## üõ†Ô∏è **Implementation Specification**

### **Phase 1: Type Definitions**

#### **File: `DOT.Polkadot.Import.Types.ts`**

```typescript
// ==========================================
// Type Definitions for Polkadot Import System
// ==========================================

/**
 * Import method selection
 */
export type PolkadotImportMethod = 'exodus' | 'polkadotjs' | 'auto';

/**
 * Input format types
 */
export type PolkadotInputFormat = 
  | 'privateKey'   // 64-char hex string
  | 'mnemonic'     // 12/24-word BIP39 phrase
  | 'keystore'     // Encrypted .keystore file
  | 'json';        // Plain JSON export

/**
 * Crypto type for key generation
 */
export type PolkadotCryptoType = 'sr25519' | 'ed25519' | 'ecdsa';

/**
 * Import input structure
 */
export interface PolkadotImportInput {
  format: PolkadotInputFormat;
  data: string | object; // Raw input data
  password?: string; // Required for encrypted formats
  method?: PolkadotImportMethod; // Manual override
  cryptoType?: PolkadotCryptoType; // Manual crypto type selection
}

/**
 * Import result structure
 */
export interface PolkadotImportResult {
  success: boolean;
  privateKey?: string; // 64-char hex (no 0x prefix)
  publicKey?: string; // Hex public key
  address?: string; // SS58-encoded address
  cryptoType?: PolkadotCryptoType;
  method: PolkadotImportMethod; // Which method was used
  error?: string;
  warnings?: string[];
}

/**
 * Format detection result
 */
export interface FormatDetectionResult {
  format: PolkadotInputFormat;
  method: PolkadotImportMethod;
  confidence: 'high' | 'medium' | 'low';
  indicators: string[];
}

/**
 * Keystore structure (standard Polkadot)
 */
export interface PolkadotKeystoreJson {
  encoded: string;
  encoding: {
    content: string[];
    type: string[];
    version: string;
  };
  address: string;
  meta: {
    name?: string;
    genesisHash?: string;
    whenCreated?: number;
    [key: string]: unknown;
  };
}

/**
 * LoginStandard JSON structure
 */
export interface LoginStandardPolkadotJson {
  version: number | string;
  currency: string;
  privateKey: string;
  publicKey: string;
  address: string;
  exportDate: string;
  exportedBy: string;
  warning?: string;
}
```

---

### **Phase 2: Format Detection**

#### **File: `DOT.Polkadot.Import.Detect.ts`**

```typescript
// ==========================================
// Format Detection for Polkadot Import
// ==========================================

import type {
  PolkadotInputFormat,
  PolkadotImportMethod,
  FormatDetectionResult,
  PolkadotKeystoreJson,
  LoginStandardPolkadotJson
} from './DOT.Polkadot.Import.Types';

/**
 * Detects the input format and suggests an import method
 */
export function detectPolkadotFormat(input: string | object): FormatDetectionResult {
  console.log('üîç [POLKADOT-IMPORT] Detecting format...');

  // Handle object input (parsed JSON or keystore)
  if (typeof input === 'object') {
    return detectJsonFormat(input);
  }

  // Handle string input
  const trimmed = input.trim();

  // Check for private key (64-char hex)
  if (isPrivateKey(trimmed)) {
    return {
      format: 'privateKey',
      method: 'auto', // Will try both methods
      confidence: 'high',
      indicators: ['64-character hex string']
    };
  }

  // Check for mnemonic (12/24 words)
  if (isMnemonic(trimmed)) {
    return {
      format: 'mnemonic',
      method: 'auto', // Will try both methods
      confidence: 'high',
      indicators: ['BIP39 mnemonic phrase detected']
    };
  }

  // Try parsing as JSON
  try {
    const parsed = JSON.parse(trimmed);
    return detectJsonFormat(parsed);
  } catch {
    // Not valid JSON
  }

  // Unknown format
  return {
    format: 'privateKey', // Default fallback
    method: 'auto',
    confidence: 'low',
    indicators: ['Unknown format, defaulting to private key']
  };
}

/**
 * Detects JSON format (keystore vs plain JSON)
 */
function detectJsonFormat(obj: any): FormatDetectionResult {
  // Check for Polkadot keystore format
  if (isPolkadotKeystore(obj)) {
    const method = detectKeystoreMethod(obj);
    return {
      format: 'keystore',
      method: method,
      confidence: 'high',
      indicators: [
        'Polkadot keystore detected',
        `Encoding: ${obj.encoding?.content?.join(', ')}`,
        `Method: ${method}`
      ]
    };
  }

  // Check for LoginStandard JSON format
  if (isLoginStandardJson(obj)) {
    return {
      format: 'json',
      method: 'polkadotjs', // LoginStandard uses Polkadot.js method
      confidence: 'high',
      indicators: [
        'LoginStandard JSON format',
        'Contains unencrypted private key'
      ]
    };
  }

  // Unknown JSON structure
  return {
    format: 'json',
    method: 'auto',
    confidence: 'low',
    indicators: ['Unknown JSON structure']
  };
}

/**
 * Checks if input is a valid private key
 */
function isPrivateKey(input: string): boolean {
  const cleaned = input.replace(/^0x/, '');
  return /^[0-9a-fA-F]{64}$/.test(cleaned);
}

/**
 * Checks if input is a valid mnemonic
 */
function isMnemonic(input: string): boolean {
  const words = input.trim().split(/\s+/);
  return [12, 15, 18, 21, 24].includes(words.length);
}

/**
 * Checks if object is a Polkadot keystore
 */
function isPolkadotKeystore(obj: any): obj is PolkadotKeystoreJson {
  return (
    typeof obj === 'object' &&
    typeof obj.encoded === 'string' &&
    typeof obj.encoding === 'object' &&
    Array.isArray(obj.encoding.content) &&
    Array.isArray(obj.encoding.type) &&
    typeof obj.address === 'string'
  );
}

/**
 * Checks if object is LoginStandard JSON format
 */
function isLoginStandardJson(obj: any): obj is LoginStandardPolkadotJson {
  return (
    typeof obj === 'object' &&
    obj.currency === 'DOT' &&
    typeof obj.privateKey === 'string' &&
    typeof obj.address === 'string' &&
    obj.exportedBy === 'LoginStandard'
  );
}

/**
 * Detects which method created the keystore
 */
function detectKeystoreMethod(keystore: PolkadotKeystoreJson): PolkadotImportMethod {
  // Check meta.name for indicators
  const name = keystore.meta?.name?.toLowerCase() || '';
  
  if (name.includes('exodus')) {
    return 'exodus';
  }

  if (name.includes('polkadot') || name.includes('talisman') || name.includes('subwallet')) {
    return 'polkadotjs';
  }

  // Check address prefix
  // Exodus may use different SS58 prefix
  const address = keystore.address;
  if (address.startsWith('5')) {
    // Standard Polkadot address (prefix 0)
    return 'polkadotjs';
  }

  // Default to auto (will try both)
  return 'auto';
}

/**
 * Validates password strength for encryption
 */
export function validatePassword(password: string): { valid: boolean; message?: string } {
  if (!password || password.length < 8) {
    return { valid: false, message: 'Password must be at least 8 characters' };
  }
  return { valid: true };
}
```

---

### **Phase 3: Polkadot.js Import Implementation**

#### **File: `DOT.Polkadot.Import.PolkadotJs.ts`**

```typescript
// ==========================================
// Polkadot.js Method Import Implementation
// ==========================================

import { Keyring } from '@polkadot/keyring';
import { mnemonicToMiniSecret, cryptoWaitReady } from '@polkadot/util-crypto';
import { hexToU8a, u8aToHex } from '@polkadot/util';
import type {
  PolkadotImportResult,
  PolkadotCryptoType,
  PolkadotKeystoreJson,
  LoginStandardPolkadotJson
} from './DOT.Polkadot.Import.Types';

/**
 * Import from private key using Polkadot.js method
 */
export async function importPrivateKeyPolkadotJs(
  privateKey: string,
  cryptoType: PolkadotCryptoType = 'sr25519'
): Promise<PolkadotImportResult> {
  console.log('üîë [POLKADOT-IMPORT-PJS] Importing private key...');
  
  try {
    await cryptoWaitReady();

    // Clean private key
    const cleanPrivateKey = privateKey.replace(/^0x/, '');
    
    if (cleanPrivateKey.length !== 64) {
      throw new Error(`Invalid private key length: expected 64, got ${cleanPrivateKey.length}`);
    }

    // Create keyring
    const keyring = new Keyring({ type: cryptoType });
    
    // Convert hex to Uint8Array (treat as seed)
    const privateKeyBytes = hexToU8a(`0x${cleanPrivateKey}`);
    
    // Add from seed
    const pair = keyring.addFromSeed(privateKeyBytes);

    console.log(`‚úÖ [POLKADOT-IMPORT-PJS] Success: ${pair.address}`);

    return {
      success: true,
      privateKey: cleanPrivateKey,
      publicKey: u8aToHex(pair.publicKey).replace(/^0x/, ''),
      address: pair.address,
      cryptoType: cryptoType,
      method: 'polkadotjs'
    };
  } catch (error) {
    console.error('‚ùå [POLKADOT-IMPORT-PJS] Failed:', error);
    return {
      success: false,
      method: 'polkadotjs',
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Import from mnemonic using Polkadot.js method
 */
export async function importMnemonicPolkadotJs(
  mnemonic: string,
  cryptoType: PolkadotCryptoType = 'sr25519',
  derivationPath?: string
): Promise<PolkadotImportResult> {
  console.log('üìù [POLKADOT-IMPORT-PJS] Importing mnemonic...');
  
  try {
    await cryptoWaitReady();

    // Create keyring
    const keyring = new Keyring({ type: cryptoType });
    
    // Add from mnemonic with optional derivation path
    const pair = derivationPath
      ? keyring.addFromUri(`${mnemonic}${derivationPath}`)
      : keyring.addFromMnemonic(mnemonic);

    // Extract private key (seed)
    const seed = mnemonicToMiniSecret(mnemonic);
    const privateKey = u8aToHex(seed).replace(/^0x/, '');

    console.log(`‚úÖ [POLKADOT-IMPORT-PJS] Success: ${pair.address}`);

    return {
      success: true,
      privateKey: privateKey,
      publicKey: u8aToHex(pair.publicKey).replace(/^0x/, ''),
      address: pair.address,
      cryptoType: cryptoType,
      method: 'polkadotjs'
    };
  } catch (error) {
    console.error('‚ùå [POLKADOT-IMPORT-PJS] Failed:', error);
    return {
      success: false,
      method: 'polkadotjs',
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Import from encrypted keystore using Polkadot.js method
 */
export async function importKeystorePolkadotJs(
  keystore: PolkadotKeystoreJson,
  password: string
): Promise<PolkadotImportResult> {
  console.log('üîê [POLKADOT-IMPORT-PJS] Importing keystore...');
  
  try {
    await cryptoWaitReady();

    // Detect crypto type from encoding
    const cryptoType = (keystore.encoding.content[1] || 'sr25519') as PolkadotCryptoType;
    
    // Create keyring
    const keyring = new Keyring({ type: cryptoType });
    
    // Add from JSON
    const pair = keyring.addFromJson(keystore as any);
    
    // Decrypt with password
    pair.decodePkcs8(password);

    if (pair.isLocked) {
      throw new Error('Failed to decrypt keystore - wrong password');
    }

    // Extract private key (this is tricky as Polkadot.js doesn't expose it directly)
    // We can only verify the address matches
    console.log(`‚úÖ [POLKADOT-IMPORT-PJS] Success: ${pair.address}`);
    console.log(`‚ö†Ô∏è [POLKADOT-IMPORT-PJS] Note: Private key not extracted (use pair object)`);

    return {
      success: true,
      // privateKey: undefined, // Cannot extract easily from decrypted pair
      publicKey: u8aToHex(pair.publicKey).replace(/^0x/, ''),
      address: pair.address,
      cryptoType: cryptoType,
      method: 'polkadotjs',
      warnings: ['Private key not extracted - keystore decrypted successfully']
    };
  } catch (error) {
    console.error('‚ùå [POLKADOT-IMPORT-PJS] Failed:', error);
    return {
      success: false,
      method: 'polkadotjs',
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Import from LoginStandard JSON using Polkadot.js method
 */
export async function importJsonPolkadotJs(
  json: LoginStandardPolkadotJson
): Promise<PolkadotImportResult> {
  console.log('üìÑ [POLKADOT-IMPORT-PJS] Importing JSON...');
  
  // JSON contains unencrypted private key, just validate and import
  return importPrivateKeyPolkadotJs(json.privateKey);
}
```

---

### **Phase 4: Exodus Import Implementation**

#### **File: `DOT.Polkadot.Import.Exodus.ts`**

```typescript
// ==========================================
// Exodus Method Import Implementation
// ==========================================

import { Keyring } from '@polkadot/keyring';
import { mnemonicToMiniSecret, cryptoWaitReady } from '@polkadot/util-crypto';
import { hexToU8a, u8aToHex } from '@polkadot/util';
import type {
  PolkadotImportResult,
  PolkadotCryptoType,
  PolkadotKeystoreJson
} from './DOT.Polkadot.Import.Types';

/**
 * Import from private key using Exodus method
 * Note: May differ from Polkadot.js in key interpretation
 */
export async function importPrivateKeyExodus(
  privateKey: string,
  cryptoType: PolkadotCryptoType = 'sr25519'
): Promise<PolkadotImportResult> {
  console.log('üîë [POLKADOT-IMPORT-EXODUS] Importing private key...');
  
  try {
    await cryptoWaitReady();

    // Clean private key
    const cleanPrivateKey = privateKey.replace(/^0x/, '');
    
    if (cleanPrivateKey.length !== 64) {
      throw new Error(`Invalid private key length: expected 64, got ${cleanPrivateKey.length}`);
    }

    // Exodus may use Ed25519 by default (check documentation)
    // For now, we'll try the provided cryptoType
    const keyring = new Keyring({ type: cryptoType });
    
    // Exodus may interpret the private key differently
    // Test both interpretations if needed
    const privateKeyBytes = hexToU8a(`0x${cleanPrivateKey}`);
    
    const pair = keyring.addFromSeed(privateKeyBytes);

    console.log(`‚úÖ [POLKADOT-IMPORT-EXODUS] Success: ${pair.address}`);

    return {
      success: true,
      privateKey: cleanPrivateKey,
      publicKey: u8aToHex(pair.publicKey).replace(/^0x/, ''),
      address: pair.address,
      cryptoType: cryptoType,
      method: 'exodus'
    };
  } catch (error) {
    console.error('‚ùå [POLKADOT-IMPORT-EXODUS] Failed:', error);
    return {
      success: false,
      method: 'exodus',
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Import from mnemonic using Exodus method
 * Uses Exodus-specific derivation path
 */
export async function importMnemonicExodus(
  mnemonic: string,
  cryptoType: PolkadotCryptoType = 'sr25519'
): Promise<PolkadotImportResult> {
  console.log('üìù [POLKADOT-IMPORT-EXODUS] Importing mnemonic...');
  
  try {
    await cryptoWaitReady();

    // Exodus uses specific derivation path: m/44'/354'/0'/0'/0'
    // In Substrate format: //44//354//0//0//0
    const exodusDerivationPath = "//44'//354'//0'//0'//0'";

    const keyring = new Keyring({ type: cryptoType });
    
    // Add from URI with Exodus derivation
    const pair = keyring.addFromUri(`${mnemonic}${exodusDerivationPath}`);

    // Extract seed from mnemonic
    const seed = mnemonicToMiniSecret(mnemonic);
    const privateKey = u8aToHex(seed).replace(/^0x/, '');

    console.log(`‚úÖ [POLKADOT-IMPORT-EXODUS] Success: ${pair.address}`);
    console.log(`[POLKADOT-IMPORT-EXODUS] Derivation: ${exodusDerivationPath}`);

    return {
      success: true,
      privateKey: privateKey,
      publicKey: u8aToHex(pair.publicKey).replace(/^0x/, ''),
      address: pair.address,
      cryptoType: cryptoType,
      method: 'exodus'
    };
  } catch (error) {
    console.error('‚ùå [POLKADOT-IMPORT-EXODUS] Failed:', error);
    return {
      success: false,
      method: 'exodus',
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Import from keystore using Exodus method
 * Same as Polkadot.js (both use standard PKCS#8)
 */
export async function importKeystoreExodus(
  keystore: PolkadotKeystoreJson,
  password: string
): Promise<PolkadotImportResult> {
  console.log('üîê [POLKADOT-IMPORT-EXODUS] Importing keystore...');
  
  // Exodus keystores use same format as Polkadot.js
  // Import using standard method
  const { importKeystorePolkadotJs } = await import('./DOT.Polkadot.Import.PolkadotJs');
  const result = await importKeystorePolkadotJs(keystore, password);
  
  // Override method to 'exodus'
  return {
    ...result,
    method: 'exodus'
  };
}
```

---

### **Phase 5: Main Import Orchestrator**

#### **File: `DOT.Polkadot.Import.ts`**

```typescript
// ==========================================
// Main Polkadot Import Orchestrator
// ==========================================

import { detectPolkadotFormat } from './DOT.Polkadot.Import.Detect';
import {
  importPrivateKeyPolkadotJs,
  importMnemonicPolkadotJs,
  importKeystorePolkadotJs,
  importJsonPolkadotJs
} from './DOT.Polkadot.Import.PolkadotJs';
import {
  importPrivateKeyExodus,
  importMnemonicExodus,
  importKeystoreExodus
} from './DOT.Polkadot.Import.Exodus';
import type {
  PolkadotImportInput,
  PolkadotImportResult,
  PolkadotImportMethod
} from './DOT.Polkadot.Import.Types';

/**
 * Main import function - handles all formats and methods
 */
export async function importPolkadot(input: PolkadotImportInput): Promise<PolkadotImportResult> {
  console.log('üöÄ [POLKADOT-IMPORT] Starting import process...');
  console.log(`[POLKADOT-IMPORT] Format: ${input.format}`);
  console.log(`[POLKADOT-IMPORT] Method: ${input.method || 'auto'}`);

  // Auto-detect format if needed
  if (!input.format) {
    const detection = detectPolkadotFormat(input.data);
    console.log(`[POLKADOT-IMPORT] Auto-detected format: ${detection.format}`);
    console.log(`[POLKADOT-IMPORT] Suggested method: ${detection.method}`);
    input.format = detection.format;
    input.method = input.method || detection.method;
  }

  // Determine final method
  const method = input.method || 'auto';

  // Route to appropriate import function
  switch (input.format) {
    case 'privateKey':
      return importPrivateKey(input.data as string, method, input.cryptoType);
    
    case 'mnemonic':
      return importMnemonic(input.data as string, method, input.cryptoType);
    
    case 'keystore':
      if (!input.password) {
        return {
          success: false,
          method: method,
          error: 'Password required for keystore import'
        };
      }
      return importKeystore(input.data, method, input.password);
    
    case 'json':
      return importJson(input.data, method);
    
    default:
      return {
        success: false,
        method: method,
        error: `Unsupported format: ${input.format}`
      };
  }
}

/**
 * Import private key with method selection
 */
async function importPrivateKey(
  privateKey: string,
  method: PolkadotImportMethod,
  cryptoType?: 'sr25519' | 'ed25519'
): Promise<PolkadotImportResult> {
  const crypto = cryptoType || 'sr25519';

  if (method === 'exodus') {
    return importPrivateKeyExodus(privateKey, crypto);
  }

  if (method === 'polkadotjs') {
    return importPrivateKeyPolkadotJs(privateKey, crypto);
  }

  // Auto mode: try both methods
  console.log('[POLKADOT-IMPORT] Auto mode: trying both methods...');
  
  // Try Polkadot.js first
  const pjsResult = await importPrivateKeyPolkadotJs(privateKey, crypto);
  if (pjsResult.success) {
    return pjsResult;
  }

  // Try Exodus
  const exodusResult = await importPrivateKeyExodus(privateKey, crypto);
  if (exodusResult.success) {
    return exodusResult;
  }

  // Both failed
  return {
    success: false,
    method: 'auto',
    error: 'Failed to import with both methods',
    warnings: [
      `Polkadot.js error: ${pjsResult.error}`,
      `Exodus error: ${exodusResult.error}`
    ]
  };
}

/**
 * Import mnemonic with method selection
 */
async function importMnemonic(
  mnemonic: string,
  method: PolkadotImportMethod,
  cryptoType?: 'sr25519' | 'ed25519'
): Promise<PolkadotImportResult> {
  const crypto = cryptoType || 'sr25519';

  if (method === 'exodus') {
    return importMnemonicExodus(mnemonic, crypto);
  }

  if (method === 'polkadotjs') {
    return importMnemonicPolkadotJs(mnemonic, crypto);
  }

  // Auto mode: try both methods
  console.log('[POLKADOT-IMPORT] Auto mode: trying both methods...');
  
  // Try Polkadot.js first (more common)
  const pjsResult = await importMnemonicPolkadotJs(mnemonic, crypto);
  if (pjsResult.success) {
    return pjsResult;
  }

  // Try Exodus
  const exodusResult = await importMnemonicExodus(mnemonic, crypto);
  if (exodusResult.success) {
    return exodusResult;
  }

  // Both failed
  return {
    success: false,
    method: 'auto',
    error: 'Failed to import with both methods'
  };
}

/**
 * Import keystore with method selection
 */
async function importKeystore(
  data: string | object,
  method: PolkadotImportMethod,
  password: string
): Promise<PolkadotImportResult> {
  // Parse if string
  const keystore = typeof data === 'string' ? JSON.parse(data) : data;

  if (method === 'exodus') {
    return importKeystoreExodus(keystore, password);
  }

  if (method === 'polkadotjs') {
    return importKeystorePolkadotJs(keystore, password);
  }

  // Auto mode: both methods use same standard
  return importKeystorePolkadotJs(keystore, password);
}

/**
 * Import JSON with method selection
 */
async function importJson(
  data: string | object,
  method: PolkadotImportMethod
): Promise<PolkadotImportResult> {
  // Parse if string
  const json = typeof data === 'string' ? JSON.parse(data) : data;

  // LoginStandard JSON contains plain private key
  return importJsonPolkadotJs(json);
}
```

---

## üé® **UI/UX Implementation**

### **Import Modal Component**

```typescript
// src/components/global/privateKeyManagement/Importing.DOT.tsx

import React, { useState } from 'react';
import { importPolkadot } from '@/components/currencies/ext.DOT.Polkadot/DOT.Polkadot.Import';
import type { PolkadotImportMethod, PolkadotInputFormat } from '@/components/currencies/ext.DOT.Polkadot/DOT.Polkadot.Import.Types';

export function PolkadotImportModal() {
  const [inputFormat, setInputFormat] = useState<PolkadotInputFormat>('privateKey');
  const [importMethod, setImportMethod] = useState<PolkadotImportMethod>('auto');
  const [inputData, setInputData] = useState('');
  const [password, setPassword] = useState('');
  const [result, setResult] = useState<any>(null);

  const handleImport = async () => {
    const result = await importPolkadot({
      format: inputFormat,
      data: inputData,
      password: password || undefined,
      method: importMethod
    });

    setResult(result);

    if (result.success) {
      // Handle successful import
      console.log('Import successful:', result);
    } else {
      // Handle error
      console.error('Import failed:', result.error);
    }
  };

  return (
    <div className="import-modal">
      <h2>Import Polkadot Wallet</h2>

      {/* Format Selection */}
      <div className="format-selection">
        <label>Input Format:</label>
        <select value={inputFormat} onChange={(e) => setInputFormat(e.target.value as PolkadotInputFormat)}>
          <option value="privateKey">Private Key (64-char hex)</option>
          <option value="mnemonic">Mnemonic Seed (12/24 words)</option>
          <option value="keystore">Encrypted Keystore (.keystore)</option>
          <option value="json">JSON Export (.json)</option>
        </select>
      </div>

      {/* Method Selection */}
      <div className="method-selection">
        <label>Import Method:</label>
        <select value={importMethod} onChange={(e) => setImportMethod(e.target.value as PolkadotImportMethod)}>
          <option value="auto">üîÑ Auto-detect (Recommended)</option>
          <option value="polkadotjs">Polkadot.js Standard</option>
          <option value="exodus">Exodus Wallet</option>
        </select>
        <p className="help-text">
          {importMethod === 'auto' && 'Will automatically try both methods'}
          {importMethod === 'polkadotjs' && 'Official Polkadot.js derivation'}
          {importMethod === 'exodus' && 'Uses Exodus-specific derivation path'}
        </p>
      </div>

      {/* Input Field */}
      <div className="input-field">
        <label>
          {inputFormat === 'privateKey' && 'Private Key:'}
          {inputFormat === 'mnemonic' && 'Mnemonic Phrase:'}
          {inputFormat === 'keystore' && 'Upload Keystore File:'}
          {inputFormat === 'json' && 'Upload JSON File:'}
        </label>
        
        {(inputFormat === 'keystore' || inputFormat === 'json') ? (
          <input type="file" onChange={(e) => {
            const file = e.target.files?.[0];
            if (file) {
              file.text().then(setInputData);
            }
          }} />
        ) : (
          <textarea
            value={inputData}
            onChange={(e) => setInputData(e.target.value)}
            placeholder={
              inputFormat === 'privateKey' 
                ? 'Enter 64-character hex private key...'
                : 'Enter 12 or 24 word mnemonic phrase...'
            }
          />
        )}
      </div>

      {/* Password Field (for encrypted formats) */}
      {inputFormat === 'keystore' && (
        <div className="password-field">
          <label>Password:</label>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="Enter keystore password..."
          />
        </div>
      )}

      {/* Import Button */}
      <button onClick={handleImport}>Import Wallet</button>

      {/* Result Display */}
      {result && (
        <div className={`result ${result.success ? 'success' : 'error'}`}>
          {result.success ? (
            <>
              <h3>‚úÖ Import Successful</h3>
              <p>Address: {result.address}</p>
              <p>Method: {result.method}</p>
            </>
          ) : (
            <>
              <h3>‚ùå Import Failed</h3>
              <p>Error: {result.error}</p>
            </>
          )}
        </div>
      )}
    </div>
  );
}
```

---

## üß™ **Testing Strategy**

### **Test Cases**

#### **1. Private Key Import**
```typescript
describe('Polkadot Private Key Import', () => {
  const testPrivateKey = '897b7779baa17fcfcd0f335cf1d9729a2b17cbabe98278384793e68c8b30273a';

  test('Import with Polkadot.js method', async () => {
    const result = await importPolkadot({
      format: 'privateKey',
      data: testPrivateKey,
      method: 'polkadotjs'
    });

    expect(result.success).toBe(true);
    expect(result.address).toBeDefined();
  });

  test('Import with Exodus method', async () => {
    const result = await importPolkadot({
      format: 'privateKey',
      data: testPrivateKey,
      method: 'exodus'
    });

    expect(result.success).toBe(true);
    expect(result.address).toBeDefined();
  });

  test('Import with auto method', async () => {
    const result = await importPolkadot({
      format: 'privateKey',
      data: testPrivateKey,
      method: 'auto'
    });

    expect(result.success).toBe(true);
    expect(['polkadotjs', 'exodus']).toContain(result.method);
  });
});
```

#### **2. Mnemonic Import**
```typescript
describe('Polkadot Mnemonic Import', () => {
  const testMnemonic = 'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about';

  test('Import with Polkadot.js method', async () => {
    const result = await importPolkadot({
      format: 'mnemonic',
      data: testMnemonic,
      method: 'polkadotjs'
    });

    expect(result.success).toBe(true);
    expect(result.address).toBe('5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY');
  });

  test('Import with Exodus method', async () => {
    const result = await importPolkadot({
      format: 'mnemonic',
      data: testMnemonic,
      method: 'exodus'
    });

    expect(result.success).toBe(true);
    // Exodus should produce different address due to derivation path
    expect(result.address).toBeDefined();
  });
});
```

#### **3. Keystore Import**
```typescript
describe('Polkadot Keystore Import', () => {
  const testKeystore = {
    encoded: 'qZwrXD25Hkw9cFsOMcnbSQ3xsIPSF3...',
    encoding: {
      content: ['pkcs8', 'sr25519'],
      type: ['scrypt', 'xsalsa20-poly1305'],
      version: '3'
    },
    address: '5CcEfDpDkMfmx4TtKH2XFBUWcSsF6Ej3KyQs85MWPB9gfR6g',
    meta: { name: 'Test Account' }
  };

  test('Import with correct password', async () => {
    const result = await importPolkadot({
      format: 'keystore',
      data: testKeystore,
      password: 'test123',
      method: 'auto'
    });

    expect(result.success).toBe(true);
  });

  test('Import with wrong password', async () => {
    const result = await importPolkadot({
      format: 'keystore',
      data: testKeystore,
      password: 'wrongpassword',
      method: 'auto'
    });

    expect(result.success).toBe(false);
    expect(result.error).toContain('password');
  });
});
```

#### **4. JSON Import**
```typescript
describe('Polkadot JSON Import', () => {
  const testJson = {
    version: 1,
    currency: 'DOT',
    privateKey: '897b7779baa17fcfcd0f335cf1d9729a2b17cbabe98278384793e68c8b30273a',
    address: '14fE5qfnn1sqmbynkMvmEx4DFuNEe4UMLLTkb3tjaKeT7yV4',
    exportedBy: 'LoginStandard'
  };

  test('Import LoginStandard JSON', async () => {
    const result = await importPolkadot({
      format: 'json',
      data: testJson,
      method: 'auto'
    });

    expect(result.success).toBe(true);
    expect(result.privateKey).toBe(testJson.privateKey);
  });
});
```

---

## üìã **Implementation Checklist**

### **Phase 1: Type Definitions ‚úÖ**
- [ ] Create `DOT.Polkadot.Import.Types.ts`
- [ ] Define all interfaces and types
- [ ] Export type definitions

### **Phase 2: Format Detection ‚úÖ**
- [ ] Create `DOT.Polkadot.Import.Detect.ts`
- [ ] Implement format detection logic
- [ ] Implement method detection heuristics
- [ ] Add validation functions

### **Phase 3: Polkadot.js Implementation ‚úÖ**
- [ ] Create `DOT.Polkadot.Import.PolkadotJs.ts`
- [ ] Implement private key import
- [ ] Implement mnemonic import
- [ ] Implement keystore import
- [ ] Implement JSON import

### **Phase 4: Exodus Implementation ‚úÖ**
- [ ] Create `DOT.Polkadot.Import.Exodus.ts`
- [ ] Implement private key import (Exodus method)
- [ ] Implement mnemonic import (with Exodus derivation)
- [ ] Implement keystore import

### **Phase 5: Main Orchestrator ‚úÖ**
- [ ] Create `DOT.Polkadot.Import.ts`
- [ ] Implement main `importPolkadot()` function
- [ ] Implement auto-detection routing
- [ ] Implement fallback logic

### **Phase 6: UI Integration**
- [ ] Create import modal component
- [ ] Add format selection dropdown
- [ ] Add method selection dropdown
- [ ] Add file upload for keystore/JSON
- [ ] Add password input for encrypted formats
- [ ] Add result display

### **Phase 7: Testing**
- [ ] Write unit tests for each import method
- [ ] Test all input formats
- [ ] Test auto-detection
- [ ] Test error handling
- [ ] Test with real Exodus exports
- [ ] Test with real Polkadot.js exports

### **Phase 8: Documentation**
- [ ] Add JSDoc comments
- [ ] Create user guide
- [ ] Document method differences
- [ ] Add troubleshooting section

---

## üöß **Known Challenges & Solutions**

### **Challenge 1: Private Key Extraction from Keystore**
**Problem:** Polkadot.js doesn't easily expose decrypted private keys from keystores.

**Solution:**
- Store the KeyringPair object instead
- Or: Use direct decryption without Polkadot.js wrapper
- Or: Accept that keystore import doesn't expose private key

### **Challenge 2: Exodus Derivation Path**
**Problem:** Exact Exodus derivation path may be undocumented.

**Solution:**
- Research Exodus source code
- Test with real Exodus exports
- Provide manual derivation path option

### **Challenge 3: Address Mismatch**
**Problem:** Same private key may produce different addresses with different methods.

**Solution:**
- Warn users when addresses don't match
- Show both addresses for comparison
- Allow user to select which address to use

### **Challenge 4: Crypto Type Selection**
**Problem:** Users may not know if their wallet uses SR25519 or Ed25519.

**Solution:**
- Auto-detect from keystore encoding
- Try both if auto-detection fails
- Show clear error messages

---

## üéØ **Success Metrics**

1. **Compatibility:** Successfully import from at least 95% of Exodus and Polkadot.js exports
2. **Accuracy:** Generated addresses match source wallets 100% of the time
3. **Usability:** Users can complete import in < 3 clicks with auto-detection
4. **Error Handling:** Clear error messages for 100% of failure cases
5. **Performance:** Import completes in < 2 seconds for all formats

---

## üìö **References**

- **Polkadot.js Documentation:** https://polkadot.js.org/docs/keyring/
- **Exodus Wallet:** https://www.exodus.com/
- **PKCS#8 Standard:** RFC 5208
- **BIP39 Mnemonic:** https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
- **SS58 Address Format:** https://github.com/paritytech/substrate/wiki/External-Address-Format-(SS58)

---

## üîÑ **Next Steps**

1. **Review Plan** - Stakeholder approval
2. **Implement Phase 1-5** - Core functionality
3. **Test with Real Data** - Verify compatibility
4. **Implement UI** - User-facing components
5. **Documentation** - User guides and API docs
6. **Release** - Deploy to production

---

*Plan created: October 5, 2025*  
*Implementation target: Phase 1-5 complete by October 12, 2025*  
*Full release target: October 19, 2025*
