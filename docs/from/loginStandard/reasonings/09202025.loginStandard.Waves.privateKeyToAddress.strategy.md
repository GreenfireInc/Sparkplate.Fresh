# WAVES Private Key to Address Derivation Strategy

## Date: September 20, 2025

## Executive Summary

The current WAVES implementation in `src/components/currencies/WAVES.Waves.ts` contains multiple critical issues preventing proper private key to address derivation. This document analyzes the problems and provides a comprehensive strategy for correct implementation.

## Current Implementation Issues

### 1. Incorrect Input Type Handling
**Problem**: The current implementation treats private keys as if they could be seed phrases, attempting multiple conversion approaches that are fundamentally incorrect.

**Current Code Issues**:
```typescript
// WRONG: Treating private keys as seeds
const wavesLib = await import('@waves/ts-lib-crypto');
const keyPair = wavesLib.keyPair(privateKey);  // This assumes privateKey is a seed
const address = wavesLib.address(privateKey);  // This assumes privateKey is a seed
```

**Correct Approach**: Private keys and seed phrases are distinct in Waves:
- **Seed phrases**: Human-readable mnemonic words (15 words)
- **Private keys**: 32-byte cryptographic keys (Base58 encoded strings ~44 chars)

### 2. Incorrect Address Generation Algorithm
**Problem**: The manual address generation uses wrong prefix values and doesn't follow the Waves specification.

**Current Issues**:
```typescript
// WRONG: Incorrect prefix construction
const prefix = new Uint8Array([1, 87]); // 1 + 'W' - this is wrong
```

**Correct Values** (from interface.ts):
```typescript
export const MAIN_NET_CHAIN_ID = 87 // 'W' = 87
export const TEST_NET_CHAIN_ID = 84 // 'T' = 84
```

### 3. Improper Cryptographic Pipeline
**Problem**: The implementation attempts manual cryptographic operations that don't match the Waves specification.

**Current Issues**:
- Incorrect hash chaining (Blake2b → Keccak → SHA256 instead of proper Waves pipeline)
- Wrong private key derivation assumptions
- Missing proper nonce handling

## Correct Waves Cryptography Overview

### Key Concepts

1. **Seed Phrases vs Private Keys**
   - Seed phrases are 15-word mnemonics used for wallet generation
   - Private keys are 32-byte Curve25519 keys derived from seeds
   - They are NOT interchangeable

2. **Waves Address Format**
   ```
   Address = Base58(Version + ChainID + PublicKeyHash + Checksum)
   Where:
   - Version = 1 (1 byte)
   - ChainID = 87 for MainNet, 84 for TestNet (1 byte)
   - PublicKeyHash = First 20 bytes of Blake2b(Keccak256(PublicKey)) (20 bytes)
   - Checksum = First 4 bytes of Blake2b(Keccak256(Version + ChainID + PublicKeyHash)) (4 bytes)
   Total: 26 bytes before Base58 encoding
   ```

3. **Key Derivation Pipeline**
   ```
   Seed Phrase → UTF-8 bytes → Nonce concatenation → Blake2b → SHA256 → SHA256 → Private Key
   Private Key → Curve25519 → Public Key
   Public Key → Blake2b(Keccak256()) → Address Hash → Address
   ```

### Proper Implementation Strategy

#### Strategy 1: Use ts-lib-crypto Library Functions (Recommended)

```typescript
import { crypto } from '@waves/ts-lib-crypto';

const wavesCrypto = crypto({ output: 'Base58' });

// For seed phrases:
const keyPair = wavesCrypto.keyPair(seedPhrase);
const address = wavesCrypto.address(seedPhrase);

// For existing private keys - convert to public key first:
const publicKey = wavesCrypto.publicKey({ privateKey: existingPrivateKey });
const address = wavesCrypto.address({ publicKey: publicKey });
```

#### Strategy 2: Manual Implementation (For Reference)

```typescript
async function deriveAddressFromPrivateKey(privateKey: string): Promise<{address: string, publicKey: string}> {
  // 1. Decode Base58 private key to bytes
  const bs58 = (await import('bs58')).default;
  const privateKeyBytes = bs58.decode(privateKey);

  // 2. Generate public key using Curve25519
  const ed25519 = await import('@noble/ed25519');
  const publicKeyBytes = await ed25519.getPublicKey(privateKeyBytes);

  // 3. Build address using proper Waves algorithm
  const { blake2b } = await import('@noble/hashes/blake2b');
  const { keccak_256 } = await import('@noble/hashes/sha3');

  // Hash public key: Blake2b(Keccak256(publicKey))
  const keccakHash = keccak_256(publicKeyBytes);
  const pkHash = blake2b(keccakHash, { dkLen: 32 });

  // Take first 20 bytes
  const addressHashPart = pkHash.slice(0, 20);

  // Build raw address: Version(1) + ChainID(87) + AddressHash(20)
  const rawAddress = new Uint8Array(1 + 1 + 20);
  rawAddress[0] = 1;        // Version
  rawAddress[1] = 87;       // MainNet Chain ID ('W')
  rawAddress.set(addressHashPart, 2);

  // Calculate checksum: Blake2b(Keccak256(rawAddress))
  const checksumKeccak = keccak_256(rawAddress);
  const checksumBlake = blake2b(checksumKeccak, { dkLen: 32 });
  const checksum = checksumBlake.slice(0, 4);

  // Full address: rawAddress + checksum
  const fullAddress = new Uint8Array(rawAddress.length + checksum.length);
  fullAddress.set(rawAddress, 0);
  fullAddress.set(checksum, rawAddress.length);

  // Encode to Base58
  const address = bs58.encode(fullAddress);
  const publicKeyStr = bs58.encode(publicKeyBytes);

  return { address, publicKey: publicKeyStr };
}
```

## Specific Fixes Required

### 1. Fix Input Type Handling

```typescript
// BEFORE (Wrong):
const keyPair = wavesLib.keyPair(privateKey);

// AFTER (Correct):
const publicKey = wavesLib.publicKey({ privateKey: privateKey });
const address = wavesLib.address({ publicKey: publicKey });
```

### 2. Fix Address Prefix Construction

```typescript
// BEFORE (Wrong):
const prefix = new Uint8Array([1, 87]); // Manual construction

// AFTER (Correct):
// Use the library's buildAddress function or proper chain ID constants
const address = wavesLib.address({ publicKey: publicKey }, 'W'); // 'W' for MainNet
```

### 3. Remove Incorrect Approaches

**Remove these approaches**:
- Approach 1: Manual Ed25519 with direct key usage (incorrect assumptions)
- Approach 2: Hex-encoded seed (wrong input type assumption)
- Approach 3: Decoded UTF-8 seed (wrong input type assumption)
- Approach 5: Full seed processing pipeline (doesn't apply to private keys)

**Keep only**:
- Approach 4: Direct library usage with proper input types

## Implementation Recommendations

### Primary Recommendation: Use Library Functions

The most reliable approach is to use the `ts-lib-crypto` library functions directly:

```typescript
deriveFromPrivateKey: async (privateKey: string): Promise<DerivedInfo> => {
  try {
    const wavesLib = await import('@waves/ts-lib-crypto');

    // Convert private key to public key
    const publicKey = wavesLib.publicKey({ privateKey: privateKey });

    // Generate address from public key
    const address = wavesLib.address({ publicKey: publicKey });

    return {
      publicKey: publicKey,
      address: address
    };
  } catch (error) {
    throw new Error(`Waves derivation failed: ${error.message}`);
  }
}
```

### Fallback: Manual Implementation

If library usage fails, implement manual derivation using the correct Waves specification as outlined above.

## Testing Strategy

### Test Cases Required

1. **Known Private Key → Address pairs**
   ```typescript
   // Test with known Waves keypair
   const testPrivateKey = "6yCStrsBs4VgTmYcSgF37pmQhCo6t9LZk5bQqUyUNSAs";
   const expectedAddress = "3PMwoP5yMXsj7G4QDSzuTFBAM574mQbHiaa";

   const result = await deriveFromPrivateKey(testPrivateKey);
   assert(result.address === expectedAddress);
   ```

2. **Cross-validation with official tools**
   - Test against Waves Keeper wallet
   - Test against official Waves client
   - Validate against block explorer addresses

## Security Considerations

1. **Never expose private keys** in logs or error messages
2. **Validate input format** before processing
3. **Use secure random generation** for any entropy needs
4. **Handle errors gracefully** without revealing sensitive information

## Conclusion

The current implementation has fundamental misunderstandings about Waves cryptography. The key issues are:

1. Confusing private keys with seed phrases
2. Incorrect address generation algorithm
3. Improper use of cryptographic primitives

The recommended fix is to use the `ts-lib-crypto` library functions with proper input type handling, falling back to manual implementation only if necessary.

This strategy ensures compatibility with the official Waves protocol and provides reliable address derivation from private keys.
