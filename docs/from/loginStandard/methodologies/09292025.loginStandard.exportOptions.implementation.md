# 9/29/2025

LoginStandard: Export Options Implementation Guide

## Overview
Implementation guide for various export options in the Exporting.tsx component. This document provides detailed specifications and code examples for implementing JSON, encrypted JSON (BIP38), encrypted keystores, unencrypted keystores, and wallet.dat exports for UTXO currencies.

## Export Option Specifications

### **1. JSON Export**
**Type**: Plain unencrypted JSON
**Security Level**: None (unencrypted private keys)
**Use Case**: Development, backup with external encryption
**File Extension**: `.json`

#### **Structure**
```json
{
  "version": "1.0",
  "format": "LoginStandard-Plain",
  "exportType": "json",
  "timestamp": "2025-09-29T12:00:00.000Z",
  "currency": "BTC|ETH|DOT|ALGO|etc",
  "wallet": {
    "name": "Wallet Name",
    "created": "2025-09-29T12:00:00.000Z"
  },
  "keys": [
    {
      "id": "key-uuid",
      "type": "private",
      "algorithm": "secp256k1|sr25519|ed25519",
      "privateKey": "hex-string-unencrypted",
      "publicKey": "hex-string",
      "addresses": {
        "legacy": "address-string",
        "segwit": "address-string",
        "nativeSegwit": "address-string"
      }
    }
  ],
  "metadata": {
    "exportedBy": "LoginStandard",
    "warning": "⚠️ CONTAINS UNENCRYPTED PRIVATE KEYS - SECURE THIS FILE"
  }
}
```

#### **Implementation in Exporting.tsx**
```typescript
const generateJsonExport = (walletData: WalletData): string => {
  const exportData = {
    version: "1.0",
    format: "LoginStandard-Plain",
    exportType: "json",
    timestamp: new Date().toISOString(),
    currency: walletData.currency,
    wallet: {
      name: walletData.name,
      created: walletData.created
    },
    keys: walletData.keys.map(key => ({
      id: generateUUID(),
      type: "private",
      algorithm: getAlgorithmForCurrency(walletData.currency),
      privateKey: key.privateKey, // ⚠️ UNENCRYPTED
      publicKey: key.publicKey,
      addresses: generateAddresses(key, walletData.currency)
    })),
    metadata: {
      exportedBy: "LoginStandard",
      warning: "⚠️ CONTAINS UNENCRYPTED PRIVATE KEYS - SECURE THIS FILE"
    }
  };

  return JSON.stringify(exportData, null, 2);
};
```

### **2. JSON.Encrypted (BIP38)**
**Type**: BIP38 encrypted JSON
**Security Level**: Strong (BIP38 standard encryption)
**Use Case**: Secure paper wallet backups, encrypted storage
**File Extension**: `.json`
**Standard**: BIP38 (Bitcoin Improvement Proposal 38)

#### **BIP38 Encryption Process**
1. **Generate ECDSA Key**: From passphrase using scrypt
2. **Create Intermediate Code**: Base58 encoded intermediate
3. **Encrypt Private Key**: Using intermediate code
4. **Generate Confirmation Code**: For verification

#### **Structure**
```json
{
  "version": "1.0",
  "format": "LoginStandard-BIP38",
  "exportType": "json-encrypted",
  "timestamp": "2025-09-29T12:00:00.000Z",
  "currency": "BTC",
  "wallet": {
    "name": "Wallet Name"
  },
  "keys": [
    {
      "id": "key-uuid",
      "type": "private",
      "algorithm": "secp256k1",
      "bip38EncryptedKey": "6PYR...encrypted-key",
      "address": "1ABC...address",
      "confirmationCode": "cfrm38V...confirmation"
    }
  ],
  "metadata": {
    "exportedBy": "LoginStandard",
    "encryption": "BIP38",
    "warning": "Requires BIP38 passphrase to decrypt"
  }
}
```

#### **Implementation in Exporting.tsx**
```typescript
const generateBIP38EncryptedExport = async (
  walletData: WalletData,
  passphrase: string
): Promise<string> => {
  // Validate BTC currency (BIP38 is Bitcoin-specific)
  if (walletData.currency !== 'BTC') {
    throw new Error('BIP38 encryption is only supported for Bitcoin');
  }

  const encryptedKeys = await Promise.all(
    walletData.keys.map(key => encryptKeyWithBIP38(key.privateKey, passphrase))
  );

  const exportData = {
    version: "1.0",
    format: "LoginStandard-BIP38",
    exportType: "json-encrypted",
    timestamp: new Date().toISOString(),
    currency: walletData.currency,
    wallet: {
      name: walletData.name
    },
    keys: encryptedKeys.map((encrypted, index) => ({
      id: generateUUID(),
      type: "private",
      algorithm: "secp256k1",
      bip38EncryptedKey: encrypted.encryptedKey,
      address: walletData.keys[index].address,
      confirmationCode: encrypted.confirmationCode
    })),
    metadata: {
      exportedBy: "LoginStandard",
      encryption: "BIP38",
      warning: "Requires BIP38 passphrase to decrypt"
    }
  };

  return JSON.stringify(exportData, null, 2);
};

// BIP38 Encryption Implementation
const encryptKeyWithBIP38 = async (privateKey: string, passphrase: string) => {
  const CryptoJS = await import('crypto-js');

  // Generate salt and derive key using scrypt
  const salt = CryptoJS.lib.WordArray.random(4); // 32 bits
  const scryptParams = {
    keySize: 512/32, // 512 bits
    iterations: 16384,
    salt: salt
  };

  const derivedKey = CryptoJS.SCRYPT(passphrase, salt, scryptParams);

  // Split derived key
  const derivedHalf1 = derivedKey.slice(0, 32);
  const derivedHalf2 = derivedKey.slice(32);

  // Generate address hash
  const publicKey = getPublicKeyFromPrivate(privateKey);
  const address = getAddressFromPublicKey(publicKey);
  const addressHash = CryptoJS.SHA256(CryptoJS.SHA256(address)).slice(0, 4);

  // Encrypt private key
  const privateKeyBytes = CryptoJS.enc.Hex.parse(privateKey);
  const xorKey = derivedHalf2.slice(0, 32);

  // Simple XOR encryption (BIP38 specification)
  const encrypted = privateKeyBytes.map((byte, index) =>
    byte ^ xorKey[index % xorKey.length]
  );

  // Create encrypted key with checksum
  const encryptedKey = CryptoJS.lib.WordArray.create(encrypted);
  const checksum = CryptoJS.SHA256(CryptoJS.SHA256(encryptedKey)).slice(0, 4);

  const finalEncrypted = salt.concat(encryptedKey).concat(checksum);

  // Base58 encode
  const bip38Key = base58Encode(finalEncrypted);

  return {
    encryptedKey: bip38Key,
    confirmationCode: generateConfirmationCode(passphrase, address)
  };
};
```

### **3. Keystore.Encrypted**
**Type**: Encrypted keystore (Web3/Ethereum compatible)
**Security Level**: Strong (configurable encryption)
**Use Case**: Wallet imports, secure storage
**File Extension**: `.keystore`
**Standards**: Web3 Keystore v3, PKCS#8

#### **Structure**
```json
{
  "version": 3,
  "id": "uuid-string",
  "address": "hex-address",
  "crypto": {
    "ciphertext": "base64-encrypted-data",
    "cipherparams": {
      "iv": "hex-iv"
    },
    "cipher": "aes-128-ctr",
    "kdf": "scrypt|pbkdf2",
    "kdfparams": {
      "dklen": 32,
      "salt": "hex-salt",
      "n": 131072,
      "r": 8,
      "p": 1
    },
    "mac": "hex-mac"
  },
  "metadata": {
    "currency": "ETH",
    "exportedBy": "LoginStandard"
  }
}
```

#### **Implementation in Exporting.tsx**
```typescript
const generateEncryptedKeystore = async (
  privateKey: string,
  password: string,
  currency: string
): Promise<string> => {
  const CryptoJS = await import('crypto-js');

  // Generate random values
  const salt = CryptoJS.lib.WordArray.random(32);
  const iv = CryptoJS.lib.WordArray.random(16);
  const id = generateUUID();

  // Choose KDF based on currency
  const kdfConfig = getKDFConfig(currency);

  // Derive key using scrypt
  const derivedKey = CryptoJS.SCRYPT(password, salt, {
    keySize: 256/32,
    iterations: kdfConfig.n,
    salt: salt
  });

  // Encrypt private key
  const encrypted = CryptoJS.AES.encrypt(privateKey, derivedKey, {
    iv: iv,
    mode: CryptoJS.mode.CTR,
    padding: CryptoJS.pad.NoPadding
  });

  // Generate MAC for integrity
  const mac = CryptoJS.SHA3(
    derivedKey.slice(16, 32).concat(encrypted.ciphertext),
    { outputLength: 256 }
  );

  const keystore = {
    version: 3,
    id: id,
    address: getAddressFromPrivateKey(privateKey, currency),
    crypto: {
      ciphertext: encrypted.ciphertext.toString(),
      cipherparams: {
        iv: iv.toString()
      },
      cipher: "aes-128-ctr",
      kdf: "scrypt",
      kdfparams: {
        dklen: 32,
        salt: salt.toString(),
        n: kdfConfig.n,
        r: kdfConfig.r,
        p: kdfConfig.p
      },
      mac: mac.toString()
    },
    metadata: {
      currency: currency,
      exportedBy: "LoginStandard",
      exportDate: new Date().toISOString()
    }
  };

  return JSON.stringify(keystore, null, 2);
};

const getKDFConfig = (currency: string) => {
  // Stronger KDF for high-value currencies
  const configs = {
    'BTC': { n: 262144, r: 8, p: 1 }, // Very strong
    'ETH': { n: 131072, r: 8, p: 1 }, // Standard Web3
    'DOT': { n: 32768, r: 8, p: 1 },  // Polkadot standard
    'ALGO': { n: 16384, r: 8, p: 1 }  // Algorand standard
  };

  return configs[currency] || { n: 131072, r: 8, p: 1 };
};
```

### **4. Keystore.Unencrypted**
**Type**: Plain keystore without encryption
**Security Level**: None (unencrypted private keys)
**Use Case**: Development, temporary storage
**File Extension**: `.keystore`
**Warning**: Contains sensitive data

#### **Structure**
```json
{
  "version": "1.0",
  "format": "LoginStandard-Keystore-Unencrypted",
  "id": "uuid-string",
  "currency": "ETH",
  "privateKey": "hex-private-key-unencrypted",
  "publicKey": "hex-public-key",
  "address": "address-string",
  "metadata": {
    "exportedBy": "LoginStandard",
    "warning": "⚠️ CONTAINS UNENCRYPTED PRIVATE KEY",
    "exportDate": "2025-09-29T12:00:00.000Z"
  }
}
```

#### **Implementation in Exporting.tsx**
```typescript
const generateUnencryptedKeystore = (
  privateKey: string,
  publicKey: string,
  address: string,
  currency: string
): string => {
  const keystore = {
    version: "1.0",
    format: "LoginStandard-Keystore-Unencrypted",
    id: generateUUID(),
    currency: currency,
    privateKey: privateKey, // ⚠️ UNENCRYPTED
    publicKey: publicKey,
    address: address,
    metadata: {
      exportedBy: "LoginStandard",
      warning: "⚠️ CONTAINS UNENCRYPTED PRIVATE KEY",
      exportDate: new Date().toISOString()
    }
  };

  return JSON.stringify(keystore, null, 2);
};
```

### **5. Wallet.dat (UTXO Currencies)**
**Type**: Bitcoin Core wallet.dat format
**Security Level**: Configurable (encrypted or unencrypted)
**Use Case**: Bitcoin Core wallet import
**File Extension**: None (binary file)
**Supported Currencies**: BTC, LTC, BCH, DOGE

#### **Berkeley DB Structure**
```
wallet.dat structure:
├── mkey (Master key for encryption)
├── keys (Encrypted private keys)
├── ckeys (Change keys)
├── pool (Key pool)
├── tx (Transaction records)
├── names (Address labels)
└── metadata (Version, settings)
```

#### **Implementation in Exporting.tsx**
```typescript
const generateWalletDat = async (
  keys: WalletKey[],
  password?: string,
  currency: string = 'BTC'
): Promise<Uint8Array> => {
  // Create Berkeley DB structure
  const db = new BerkeleyDB();

  // Add version record
  db.put('version', 10500); // Bitcoin Core version

  // Add master key if encrypted
  if (password) {
    const masterKey = await generateMasterKey(password);
    db.put('mkey', masterKey);
  }

  // Add keys
  for (const key of keys) {
    const keyRecord = {
      publicKey: key.publicKey,
      privateKey: password ? await encryptPrivateKey(key.privateKey, password) : key.privateKey,
      created: Math.floor(Date.now() / 1000)
    };

    db.put(`key${key.publicKey}`, keyRecord);
  }

  // Add key pool
  const keyPool = generateKeyPool(100); // 100 unused keys
  db.put('pool', keyPool);

  // Add metadata
  db.put('settings', {
    defaultKey: keys[0].publicKey,
    hdChain: null // No HD chain for basic export
  });

  return db.serialize();
};

const generateMasterKey = async (password: string): Promise<Uint8Array> => {
  const CryptoJS = await import('crypto-js');

  // Use PBKDF2 to derive master key (Bitcoin Core method)
  const salt = CryptoJS.lib.WordArray.random(32);
  const derived = CryptoJS.PBKDF2(password, salt, {
    keySize: 256/32,
    iterations: 50000,
    hasher: CryptoJS.algo.SHA512
  });

  // Create master key structure
  const masterKey = new Uint8Array(48); // 32 bytes key + 16 bytes IV
  const keyBytes = wordArrayToUint8Array(derived);
  masterKey.set(keyBytes.slice(0, 32), 0); // Key
  masterKey.set(keyBytes.slice(32, 48), 32); // IV

  return masterKey;
};

const encryptPrivateKey = async (
  privateKey: string,
  password: string
): Promise<Uint8Array> => {
  const masterKey = await generateMasterKey(password);
  const CryptoJS = await import('crypto-js');

  const encrypted = CryptoJS.AES.encrypt(privateKey, masterKey.slice(0, 32), {
    iv: masterKey.slice(32),
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
  });

  return wordArrayToUint8Array(encrypted.ciphertext);
};
```

## Exporting.tsx Integration

### **UI Component Updates**
```typescript
type ExportFormat =
  | 'json'
  | 'json-encrypted-bip38'
  | 'keystore-encrypted'
  | 'keystore-unencrypted'
  | 'wallet-dat';

const Exporting = ({ privateKey, currency }: ExportingProps) => {
  const [exportFormat, setExportFormat] = useState<ExportFormat>('json');
  const [password, setPassword] = useState('');
  const [isExporting, setIsExporting] = useState(false);

  const formatOptions = [
    {
      value: 'json',
      label: 'JSON',
      description: 'Unencrypted JSON file',
      security: 'none'
    },
    {
      value: 'json-encrypted-bip38',
      label: 'JSON (BIP38 Encrypted)',
      description: 'BIP38 encrypted for Bitcoin',
      security: 'strong',
      currencyRequired: 'BTC'
    },
    {
      value: 'keystore-encrypted',
      label: 'Encrypted Keystore',
      description: 'Password-protected keystore',
      security: 'strong'
    },
    {
      value: 'keystore-unencrypted',
      label: 'Unencrypted Keystore',
      description: 'Plain keystore file',
      security: 'none'
    },
    {
      value: 'wallet-dat',
      label: 'Wallet.dat',
      description: 'Bitcoin Core format',
      security: 'configurable',
      currencies: ['BTC', 'LTC', 'BCH', 'DOGE']
    }
  ];

  const handleExport = async () => {
    setIsExporting(true);
    try {
      let content: string | Uint8Array;
      let filename: string;
      let mimeType: string;

      switch (exportFormat) {
        case 'json':
          content = generateJsonExport({ keys: [{ privateKey }], currency });
          filename = `${currency.toLowerCase()}_wallet_${Date.now()}.json`;
          mimeType = 'application/json';
          break;

        case 'json-encrypted-bip38':
          content = await generateBIP38EncryptedExport({ keys: [{ privateKey }], currency }, password);
          filename = `${currency.toLowerCase()}_wallet_bip38_${Date.now()}.json`;
          mimeType = 'application/json';
          break;

        case 'keystore-encrypted':
          content = await generateEncryptedKeystore(privateKey, password, currency);
          filename = `UTC--${new Date().toISOString().split('T')[0]}--${getAddressFromPrivateKey(privateKey, currency)}.keystore`;
          mimeType = 'application/json';
          break;

        case 'keystore-unencrypted':
          content = generateUnencryptedKeystore(privateKey, '', getAddressFromPrivateKey(privateKey, currency), currency);
          filename = `${currency.toLowerCase()}_keystore_${Date.now()}.keystore`;
          mimeType = 'application/json';
          break;

        case 'wallet-dat':
          content = await generateWalletDat([{ privateKey }], password, currency);
          filename = 'wallet.dat';
          mimeType = 'application/octet-stream';
          break;
      }

      downloadFile(content, filename, mimeType);
      toast.success(`${exportFormat.toUpperCase()} exported successfully`);

    } catch (error) {
      toast.error(`Export failed: ${error.message}`);
    } finally {
      setIsExporting(false);
    }
  };

  return (
    <div className="export-options">
      <Select value={exportFormat} onValueChange={setExportFormat}>
        <SelectTrigger>
          <SelectValue />
        </SelectTrigger>
        <SelectContent>
          {formatOptions
            .filter(option =>
              !option.currencyRequired || option.currencyRequired === currency
            )
            .filter(option =>
              !option.currencies || option.currencies.includes(currency)
            )
            .map(option => (
              <SelectItem key={option.value} value={option.value}>
                <div className="flex flex-col">
                  <span className="font-medium">{option.label}</span>
                  <span className="text-sm text-muted-foreground">
                    {option.description}
                  </span>
                </div>
              </SelectItem>
            ))
          }
        </SelectContent>
      </Select>

      {/* Password input for encrypted formats */}
      {['json-encrypted-bip38', 'keystore-encrypted', 'wallet-dat'].includes(exportFormat) && (
        <Input
          type="password"
          placeholder="Enter encryption password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
      )}

      {/* Security warnings */}
      {exportFormat.includes('unencrypted') && (
        <Alert variant="destructive">
          <AlertTriangle className="h-4 w-4" />
          <AlertDescription>
            This export contains unencrypted private keys. Store securely!
          </AlertDescription>
        </Alert>
      )}

      <Button onClick={handleExport} disabled={isExporting}>
        {isExporting ? 'Exporting...' : 'Export'}
      </Button>
    </div>
  );
};
```

## Security Considerations

### **Format Selection Guidelines**
- **JSON**: Use only for development or with external encryption
- **JSON.Encrypted (BIP38)**: Preferred for Bitcoin paper wallets
- **Keystore.Encrypted**: Standard for wallet applications
- **Keystore.Unencrypted**: Avoid in production environments
- **Wallet.dat**: Use for Bitcoin Core compatibility

### **Password Requirements**
- **Minimum Length**: 8 characters
- **Complexity**: Mixed case, numbers, symbols
- **Storage**: Never store passwords in code
- **Validation**: Confirm password for critical exports

### **File Handling**
- **Memory Clearing**: Zero-out sensitive data after export
- **Secure Download**: Use Blob URLs with proper cleanup
- **File Naming**: Include timestamps and identifiers
- **Size Limits**: Handle large wallet exports gracefully

## Testing Strategy

### **Unit Tests**
```typescript
describe('Export Formats', () => {
  test('JSON export contains correct structure', () => {
    const result = generateJsonExport(testWallet);
    const parsed = JSON.parse(result);

    expect(parsed.format).toBe('LoginStandard-Plain');
    expect(parsed.keys[0].privateKey).toBeDefined();
    expect(parsed.metadata.warning).toContain('UNENCRYPTED');
  });

  test('BIP38 export requires BTC currency', async () => {
    await expect(
      generateBIP38EncryptedExport({ currency: 'ETH' }, 'password')
    ).rejects.toThrow('BIP38 encryption is only supported for Bitcoin');
  });

  test('Encrypted keystore can be decrypted', async () => {
    const exported = await generateEncryptedKeystore(testPrivateKey, 'password', 'ETH');
    const imported = await importEncryptedKeystore(exported, 'password');

    expect(imported.privateKey).toBe(testPrivateKey);
  });
});
```

### **Integration Tests**
- Test file download functionality
- Verify wallet.dat imports into Bitcoin Core
- Test BIP38 decryption with third-party tools
- Validate keystore imports in MetaMask

---

*Export options implementation guide for LoginStandard Exporting.tsx component. Provides comprehensive specifications for JSON, BIP38 encrypted JSON, encrypted keystores, unencrypted keystores, and wallet.dat exports with security considerations and testing strategies.*
