# 9/29/2025

LoginStandard: Unified Wallet Export Format Framework

## Overview
Comprehensive framework for a unified JSON export format that combines parameters from all analyzed keystore formats across multiple blockchain ecosystems. This framework enables LoginStandard to export private keys in a standardized format compatible with the Exporting.tsx component while maintaining backward compatibility with existing wallet formats.

## Format Architecture

### **Core Structure**
```json
{
  "version": "1.0",
  "format": "LoginStandard",
  "exportType": "keystore|json",
  "id": "uuid-v4-identifier",
  "timestamp": "ISO8601-timestamp",
  "currency": "blockchain-identifier",
  "wallet": {
    // Wallet-level information
  },
  "keys": [
    // Array of key objects (supports multiple keys)
  ],
  "metadata": {
    // Export and compatibility information
  }
}
```

## Key Components Analysis

### **From Dogecoin Format**
**Source**: OpenSSL encrypted credential file
**Parameters Extracted**:
- **Encryption Method**: AES-256-CBC
- **KDF**: PBKDF2
- **File Signature**: `U2FsdGVkX1+`
- **Purpose**: Password-protected credential storage

### **From Tezos Format**
**Source**: Custom Tezos keystore JSON
**Parameters Extracted**:
- **Version Field**: `"1"` (keystore version)
- **Salt Field**: Base64 encoded salt
- **Ciphertext Field**: Encrypted private key data
- **KDF Field**: `"Argon2"`
- **Key Types**: Ed25519 or secp256k1

### **From Polkadot Individual Format**
**Source**: PKCS#8/SR25519 keystore
**Parameters Extracted**:
- **Encoded Field**: Base64 encoded encrypted key
- **Encoding Object**:
  - `content`: `["pkcs8", "sr25519"]`
  - `type`: `["scrypt", "xsalsa20-poly1305"]`
  - `version`: `"3"`
- **Address Field**: SS58 encoded address
- **Meta Object**: Wallet name and metadata

### **From Polkadot Batch Format**
**Source**: Multi-account batch export
**Parameters Extracted**:
- **Batch Encoding**: `["batch-pkcs8"]`
- **Accounts Array**: Multiple account objects
- **Account Metadata**:
  - `genesisHash`
  - `name`
  - `isMasterAccount`
  - `whenCreated` (timestamp)
  - `isMasterPassword`
  - `isSubWallet`

### **From Ethereum Format**
**Source**: Web3 keystore v3
**Parameters Extracted**:
- **Version**: `3`
- **ID Field**: UUID for keystore identification
- **Crypto Object**:
  - `ciphertext`: Encrypted private key
  - `cipherparams`: IV for encryption
  - `cipher`: `"aes-128-ctr"`
  - `kdf`: `"scrypt"`
  - `kdfparams`: Complete KDF parameters
  - `mac`: Keccak-256 integrity hash
- **Address Field**: Hex encoded address

### **From Bitcoin Core Format**
**Source**: wallet.dat Berkeley DB structure
**Parameters Extracted**:
- **Database Structure**: BDB with multiple record types
- **Key Records**: `keys`, `ckeys` (change keys)
- **Master Key**: `mkey` for encryption
- **Key Pool**: `pool` for address generation
- **Metadata**: `names`, transaction records

## Unified Format Specification

### **Version 1.0 Schema**
```json
{
  "$schema": "https://loginstandard.org/schema/wallet-export-v1.0.json",
  "version": "1.0",
  "format": "LoginStandard",
  "exportType": "keystore|json",
  "id": "uuid-v4-string",
  "timestamp": "2025-09-29T12:00:00.000Z",
  "currency": "BTC|ETH|DOT|XTZ|etc",

  "wallet": {
    "name": "Wallet Name (optional)",
    "description": "User description (optional)",
    "created": "ISO8601-timestamp",
    "lastModified": "ISO8601-timestamp",
    "walletType": "hot|cold|hardware",
    "derivationPath": "m/44'/0'/0'/0/0"
  },

  "keys": [
    {
      "id": "key-uuid",
      "type": "private|public|extended",
      "algorithm": "secp256k1|sr25519|ed25519",
      "purpose": "spend|stake|multisig",

      "keyData": {
        "privateKey": "hex-string (unencrypted only)",
        "publicKey": "hex-string",
        "chainCode": "hex-string (for extended keys)",
        "wif": "base58-string (Bitcoin)",
        "ss58": "string (Polkadot)",
        "bech32": "string (Stacks)"
      },

      "addresses": {
        "legacy": "address-string",
        "segwit": "address-string",
        "nativeSegwit": "address-string",
        "taproot": "address-string",
        "contract": "address-string (for smart contracts)"
      },

      "derivation": {
        "path": "m/44'/0'/0'/0/0",
        "parentFingerprint": "hex-string",
        "index": 0,
        "depth": 0
      },

      "encryption": {
        "encrypted": true|false,
        "cipher": "aes-128-ctr|aes-256-cbc|xsalsa20-poly1305",
        "ciphertext": "base64-string",
        "cipherparams": {
          "iv": "hex-string"
        },
        "kdf": "scrypt|pbkdf2|argon2",
        "kdfparams": {
          "dklen": 32,
          "salt": "hex-string",
          "n": 131072,
          "r": 8,
          "p": 1,
          "iterations": 10000,
          "hash": "sha256|sha512"
        },
        "mac": "hex-string (integrity check)"
      },

      "metadata": {
        "label": "Key label",
        "created": "ISO8601-timestamp",
        "lastUsed": "ISO8601-timestamp",
        "balance": "numeric-string",
        "txCount": 0,
        "isChange": false,
        "isMultisig": false,
        "cosignerIndex": 0
      }
    }
  ],

  "metadata": {
    "exportedBy": "LoginStandard",
    "exportVersion": "1.0.0",
    "platform": "web|mobile|desktop",
    "userAgent": "browser-user-agent",

    "compatibility": {
      "bitcoinCore": true,
      "electrum": true,
      "metamask": true,
      "polkadotJs": true,
      "tezosWallet": true,
      "peraWallet": true,
      "deflyWallet": true,
      "novaSpektr": true,
      "talisman": true,
      "subWallet": true
    },

    "security": {
      "encryptionStrength": "strong|medium|weak",
      "passwordRequired": true,
      "biometricRequired": false,
      "hardwareSecurity": false
    },

    "warnings": [
      "⚠️ KEEP THIS FILE SECURE - Contains sensitive cryptographic material",
      "Never share this file with untrusted parties",
      "Backup this file in multiple secure locations"
    ]
  }
}
```

## Currency-Specific Extensions

### **Bitcoin (BTC/LTC/BCH)**
```json
{
  "currency": "BTC",
  "wallet": {
    "network": "mainnet|testnet|regtest",
    "hdSeed": "encrypted-bip39-seed (optional)"
  },
  "keys": [
    {
      "algorithm": "secp256k1",
      "keyData": {
        "wif": "5K...",
        "compressed": true
      },
      "addresses": {
        "legacy": "1ABC...",
        "segwit": "3ABC...",
        "nativeSegwit": "bc1ABC...",
        "taproot": "bc1pABC..."
      }
    }
  ]
}
```

### **Ethereum (ETH/ERC20)**
```json
{
  "currency": "ETH",
  "keys": [
    {
      "algorithm": "secp256k1",
      "keyData": {
        "privateKey": "0x..."
      },
      "addresses": {
        "legacy": "0xABC...",
        "contract": "0xDEF... (if applicable)"
      },
      "encryption": {
        "cipher": "aes-128-ctr",
        "kdf": "scrypt",
        "kdfparams": {
          "n": 131072,
          "r": 8,
          "p": 1
        }
      }
    }
  ]
}
```

### **Polkadot (DOT/KSM)**
```json
{
  "currency": "DOT",
  "keys": [
    {
      "algorithm": "sr25519",
      "keyData": {
        "ss58": "1ABC..."
      },
      "addresses": {
        "legacy": "5ABC..."
      },
      "encryption": {
        "cipher": "xsalsa20-poly1305",
        "kdf": "scrypt"
      }
    }
  ]
}
```

### **Tezos (XTZ)**
```json
{
  "currency": "XTZ",
  "keys": [
    {
      "algorithm": "ed25519",
      "keyData": {
        "publicKeyHash": "tz1ABC..."
      },
      "encryption": {
        "kdf": "argon2"
      }
    }
  ]
}
```

## Implementation Framework

### **Exporting.tsx Integration**

#### **Wallet-Specific Format Selection**
```typescript
type ExportTarget = 'universal' | 'metamask' | 'pera-wallet' | 'nova-spektr' | 'talisman' | 'bitcoin-core';

const getExportFormatForTarget = (target: ExportTarget, currency: string) => {
  const formatMap = {
    'universal': 'LoginStandard',
    'metamask': currency === 'ETH' ? 'Web3KeystoreV3' : 'LoginStandard',
    'pera-wallet': currency === 'ALGO' ? 'LoginStandard-AlgoBackup' : 'LoginStandard',
    'nova-spektr': currency === 'DOT' ? 'NovaSpektr' : 'LoginStandard',
    'talisman': currency === 'DOT' ? 'LoginStandard-TalismanBackup' : 'LoginStandard',
    'bitcoin-core': currency === 'BTC' ? 'WalletDat' : 'LoginStandard'
  };

  return formatMap[target] || 'LoginStandard';
};
```

#### **JSON Export Mode**
```typescript
const generateJsonExport = (walletData: WalletData): string => {
  const exportData: UnifiedExportFormat = {
    version: "1.0",
    format: "LoginStandard",
    exportType: "json",
    id: generateUUID(),
    timestamp: new Date().toISOString(),
    currency: walletData.currency,
    wallet: {
      name: walletData.name,
      created: walletData.created,
      derivationPath: walletData.derivationPath
    },
    keys: walletData.keys.map(key => ({
      id: generateUUID(),
      type: "private",
      algorithm: getAlgorithmForCurrency(walletData.currency),
      purpose: "spend",
      keyData: {
        privateKey: key.privateKey,
        publicKey: key.publicKey,
        wif: key.wif,
        // ... other formats
      },
      addresses: generateAddresses(key, walletData.currency),
      derivation: key.derivation,
      metadata: {
        created: new Date().toISOString(),
        balance: key.balance || "0"
      }
    })),
    metadata: {
      exportedBy: "LoginStandard",
      exportVersion: "1.0.0",
      compatibility: getCompatibilityInfo(walletData.currency),
      security: {
        encryptionStrength: "none",
        passwordRequired: false
      },
      warnings: [
        "⚠️ KEEP THIS FILE SECURE - Contains unencrypted private keys",
        "Never share this file with untrusted parties"
      ]
    }
  };

  return JSON.stringify(exportData, null, 2);
};
```

#### **Keystore Export Mode**
```typescript
const generateKeystoreExport = async (
  walletData: WalletData,
  password: string
): Promise<string> => {
  const encryptedKeys = await Promise.all(
    walletData.keys.map(key => encryptKey(key, password, walletData.currency))
  );

  const exportData: UnifiedExportFormat = {
    version: "1.0",
    format: "LoginStandard",
    exportType: "keystore",
    id: generateUUID(),
    timestamp: new Date().toISOString(),
    currency: walletData.currency,
    wallet: {
      name: walletData.name,
      created: walletData.created
    },
    keys: encryptedKeys.map((encrypted, index) => ({
      id: generateUUID(),
      type: "private",
      algorithm: getAlgorithmForCurrency(walletData.currency),
      purpose: "spend",
      addresses: generateAddresses(walletData.keys[index], walletData.currency),
      derivation: walletData.keys[index].derivation,
      encryption: encrypted.encryption,
      metadata: {
        created: new Date().toISOString()
      }
    })),
    metadata: {
      exportedBy: "LoginStandard",
      exportVersion: "1.0.0",
      compatibility: getCompatibilityInfo(walletData.currency),
      security: {
        encryptionStrength: "strong",
        passwordRequired: true
      },
      warnings: [
        "Keep your encryption password secure",
        "You will need this password to import the keystore"
      ]
    }
  };

  return JSON.stringify(exportData, null, 2);
};
```

### **Encryption Strategies by Currency**

#### **Bitcoin-Compatible (BTC/LTC/BCH)**
```typescript
const encryptBitcoinKey = async (privateKey: string, password: string) => {
  // Use PBKDF2 with AES-256-CBC (compatible with wallet.dat)
  const salt = crypto.getRandomValues(new Uint8Array(32));
  const key = await crypto.subtle.deriveBits(
    {
      name: "PBKDF2",
      salt: salt,
      iterations: 50000,
      hash: "SHA-512"
    },
    await crypto.subtle.importKey("raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveBits"]),
    512
  );

  const aesKey = key.slice(0, 32);
  const iv = crypto.getRandomValues(new Uint8Array(16));

  const encrypted = await crypto.subtle.encrypt(
    { name: "AES-CBC", iv: iv },
    await crypto.subtle.importKey("raw", aesKey, "AES-CBC", false, ["encrypt"]),
    new TextEncoder().encode(privateKey)
  );

  return {
    encrypted: true,
    cipher: "aes-256-cbc",
    ciphertext: arrayBufferToBase64(encrypted),
    cipherparams: { iv: arrayBufferToHex(iv) },
    kdf: "pbkdf2",
    kdfparams: {
      dklen: 32,
      salt: arrayBufferToHex(salt),
      iterations: 50000,
      hash: "sha512"
    }
  };
};
```

#### **Ethereum-Compatible (ETH/ERC20)**
```typescript
const encryptEthereumKey = async (privateKey: string, password: string) => {
  // Use scrypt with AES-128-CTR (Web3 keystore v3 compatible)
  const salt = crypto.getRandomValues(new Uint8Array(32));
  const iv = crypto.getRandomValues(new Uint8Array(16));

  // Use crypto-js for scrypt implementation
  const CryptoJS = await import('crypto-js');
  const derivedKey = CryptoJS.SCRYPT(password, salt, {
    keySize: 256/32,
    iterations: 131072,
    salt: salt
  });

  const encrypted = CryptoJS.AES.encrypt(privateKey, derivedKey, {
    iv: iv,
    mode: CryptoJS.mode.CTR,
    padding: CryptoJS.pad.NoPadding
  });

  const mac = CryptoJS.SHA3(derivedKey.slice(16) + encrypted.ciphertext, { outputLength: 256 });

  return {
    encrypted: true,
    cipher: "aes-128-ctr",
    ciphertext: encrypted.ciphertext.toString(),
    cipherparams: { iv: iv.toString() },
    kdf: "scrypt",
    kdfparams: {
      dklen: 32,
      salt: salt.toString(),
      n: 131072,
      r: 8,
      p: 1
    },
    mac: mac.toString()
  };
};
```

#### **Polkadot-Compatible (DOT/KSM)**
```typescript
const encryptPolkadotKey = async (privateKey: string, password: string) => {
  // Use scrypt with xsalsa20-poly1305 (Polkadot keystore compatible)
  const salt = crypto.getRandomValues(new Uint8Array(32));

  // PKCS#8 container with SR25519
  const pkcs8Container = createPKCS8Container(privateKey, 'sr25519');

  const CryptoJS = await import('crypto-js');
  const derivedKey = CryptoJS.SCRYPT(password, salt, {
    keySize: 256/32,
    iterations: 32768,
    salt: salt
  });

  // Use xsalsa20-poly1305 encryption
  const encrypted = await encryptWithXSalsa20Poly1305(pkcs8Container, derivedKey);

  return {
    encrypted: true,
    cipher: "xsalsa20-poly1305",
    ciphertext: encrypted.ciphertext,
    cipherparams: { iv: encrypted.nonce },
    kdf: "scrypt",
    kdfparams: {
      dklen: 32,
      salt: salt.toString(),
      n: 32768,
      r: 8,
      p: 1
    }
  };
};
```

## Wallet-Specific Export Formats

### **Algorand Wallet Compatibility**

#### **Pera Wallet Backup Format**
**Compatible Wallets**: Pera Web Wallet, Defly Wallet, Pera Connect
**Export Structure**:
```json
{
  "version": "1.0",
  "format": "LoginStandard-AlgoBackup",
  "timestamp": "2025-09-29T12:00:00.000Z",
  "currency": "ALGO",
  "backup": {
    "suite": "AES-256-GCM",
    "ciphertext": "base64-encrypted-backup-data",
    "accounts": [
      {
        "name": "Account Name",
        "address": "ALGO_ADDRESS",
        "private_key": "base64-encoded-private-key",
        "account_type": "single",
        "metadata": "optional-json-metadata"
      }
    ]
  },
  "metadata": {
    "exportedBy": "LoginStandard",
    "compatibleWith": ["pera-wallet", "defly-wallet", "pera-connect"],
    "encryption": {
      "kdf": "scrypt",
      "kdfparams": {
        "N": 16384,
        "r": 8,
        "p": 1,
        "dkLen": 16,
        "salt": "7376f7d53ab818f03ba381cedad3940b"
      }
    }
  }
}
```

#### **Pera Wallet Import Integration**
```typescript
const exportForPeraWallet = async (accounts: AlgoAccount[], password: string) => {
  // Encrypt accounts using Pera's format
  const encryptedBackup = await encryptAlgorandBackup(accounts, password);

  return {
    version: "1.0",
    format: "LoginStandard-AlgoBackup",
    timestamp: new Date().toISOString(),
    currency: "ALGO",
    backup: {
      suite: "AES-256-GCM",
      ciphertext: encryptedBackup.ciphertext,
      accounts: accounts.map(account => ({
        name: account.name,
        address: account.address,
        private_key: account.privateKey, // base64 encoded
        account_type: "single"
      }))
    },
    metadata: {
      exportedBy: "LoginStandard",
      compatibleWith: ["pera-wallet", "defly-wallet"],
      encryption: {
        kdf: "scrypt",
        kdfparams: {
          N: 16384,
          r: 8,
          p: 1,
          dkLen: 16,
          salt: "7376f7d53ab818f03ba381cedad3940b"
        }
      }
    }
  };
};
```

### **Polkadot Wallet Compatibility**

#### **Nova Spektr Export Format**
**Compatible Wallets**: Nova Spektr (Polkadot Vault)
**Export Structure** (Text-based):
```
version: 1
public address: 1ABC...XYZ
genesis: polkadot
//polkadot: Account Name [sr25519]
genesis: kusama
//kusama: Kusama Account [sr25519]
```

#### **Nova Spektr Integration**
```typescript
const exportForNovaSpektr = (accounts: PolkadotAccount[], rootAddress: string) => {
  let output = `version: 1\n`;
  output += `public address: ${rootAddress}\n`;

  const chains = new Set<string>();
  for (const account of accounts) {
    if (!chains.has(account.chainId)) {
      chains.add(account.chainId);
      output += `genesis: ${account.chainId}\n`;
    }

    const derivationPath = account.derivationPath || `//${account.chainSpec}`;
    output += `${derivationPath}: ${account.name} [${account.keyType}]\n`;
  }

  return output;
};
```

#### **Talisman Wallet JSON Format**
**Compatible Wallets**: Talisman Extension, Talisman Web
**Export Structure**:
```json
{
  "version": "1.0",
  "format": "LoginStandard-TalismanBackup",
  "timestamp": "2025-09-29T12:00:00.000Z",
  "currency": "DOT",
  "keyring": {
    "passwordCheck": "encrypted-password-check",
    "mnemonics": [
      {
        "id": "mnemonic-hash-id",
        "name": "Mnemonic Name",
        "entropy": "encrypted-entropy",
        "confirmed": true,
        "createdAt": 1638360000000
      }
    ],
    "accounts": [
      {
        "id": "account-id",
        "name": "Account Name",
        "address": "DOT_ADDRESS",
        "type": "keypair",
        "secretKey": "encrypted-private-key",
        "publicKey": "hex-public-key",
        "curve": "ed25519",
        "createdAt": 1638360000000
      }
    ]
  },
  "metadata": {
    "exportedBy": "LoginStandard",
    "compatibleWith": ["talisman-extension", "talisman-web"],
    "encryption": {
      "method": "AES-GCM",
      "kdf": "PBKDF2"
    }
  }
}
```

#### **SubWallet Export Format**
**Compatible Wallets**: SubWallet Extension, SubWallet Mobile
**Export Structure**: Standard Polkadot keystore v3 (PKCS#8 + SR25519)

## Migration and Compatibility

### **Backward Compatibility**
- **Ethereum Keystores**: Direct import/export compatibility
- **Polkadot Keystores**: Support for both individual and batch formats
- **Tezos Keystores**: Custom format preservation
- **Bitcoin wallet.dat**: Structured import support
- **Algorand Backups**: ARC-35 standard compatibility

### **Import Compatibility**
The unified format supports importing from:
1. **Native wallet exports** (compatibility maintained)
2. **Legacy formats** (automatic conversion)
3. **Third-party exports** (standardized import)
4. **Wallet-specific formats** (Algorand, Polkadot variants)

### **Version Management**
- **Version Field**: Identifies format version
- **Migration Paths**: Automatic upgrade between versions
- **Deprecation Notices**: Clear warnings for outdated formats

## Security Considerations

### **Encryption Standards**
1. **Strong KDF**: Minimum 10,000 iterations for PBKDF2, 32K for scrypt
2. **AEAD Ciphers**: Prefer authenticated encryption where possible
3. **Key Separation**: Independent encryption for each key
4. **Salt Randomization**: Unique salt per encryption operation

### **File Integrity**
1. **MAC Verification**: Cryptographic integrity checks
2. **Format Validation**: Schema validation before processing
3. **Corruption Detection**: Automatic detection of file tampering

### **Privacy Protection**
1. **No Plaintext Storage**: Never store unencrypted keys in files
2. **Memory Clearing**: Zero-out sensitive data after use
3. **Access Logging**: Optional audit trail for security compliance

## Implementation Roadmap

### **Phase 1: Core Framework**
- [ ] Define complete JSON schema
- [ ] Implement basic encryption functions
- [ ] Create Exporting.tsx integration
- [ ] Add currency-specific address generation

### **Phase 2: Extended Compatibility**
- [ ] Support all analyzed keystore formats
- [ ] Implement import functionality
- [ ] Add batch export capabilities
- [ ] Create migration utilities
- [ ] Add Algorand wallet compatibility (Pera, Defly)
- [ ] Add Polkadot wallet compatibility (Nova Spektr, Talisman, SubWallet)

### **Phase 3: Advanced Features**
- [ ] Hardware wallet support
- [ ] Multi-signature wallet export
- [ ] Hierarchical deterministic wallet support
- [ ] Cross-chain compatibility
- [ ] Wallet-specific export format selection
- [ ] Automatic format detection for imports

---

*Unified wallet export format framework established for LoginStandard. Combines parameters from Dogecoin, Tezos, Polkadot, Ethereum, Bitcoin Core, Algorand (Pera/Defly), and Polkadot (Nova Spektr/Talisman/SubWallet) formats into a comprehensive, extensible JSON schema compatible with the Exporting.tsx component. Supports wallet-specific export formats for seamless import compatibility.*
