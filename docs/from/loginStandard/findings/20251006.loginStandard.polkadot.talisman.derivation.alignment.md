# Aligning LoginStandard Polkadot.js Method with Talisman Derivation

**Date**: October 6, 2025  
**Issue**: LoginStandard's "Polkadot.js" method should match Talisman's exact private key interpretation  
**Goal**: Ensure the same private key produces the same address in both LoginStandard and Talisman  
**Status**: üîß Implementation Required

---

## üìã **Problem Statement**

When a user:
1. Enters a private key in LoginStandard with the "Polkadot.js" toggle switch
2. Sees an address like `15T2HrAmUE7avgZHTKCNDpWrqziJNHKTzUMCtiDkxSn5uP9H`
3. Exports it as "Polkadot JSON (Encrypted)"
4. Imports into Talisman

**Expected**: Talisman shows the same address (with potential prefix conversion)  
**Actual**: Talisman may show a different address due to crypto type mismatches

---

## üîç **Root Cause Analysis**

### **How Talisman Imports Keystores**

From `talisman-dev/apps/extension/src/ui/domains/Account/AccountAdd/AccountAddJson/context.ts`:

```typescript
const createPairFromJson = ({ encoded, encoding, address, meta }: KeyringPair$Json) => {
  // Extract crypto type from encoding (default to ed25519)
  const cryptoType = Array.isArray(encoding.content) ? encoding.content[1] : "ed25519"
  const encType = Array.isArray(encoding.type) ? encoding.type : [encoding.type]
  
  return createPair(
    { toSS58: encodeAddress, type: cryptoType as KeypairType },
    { publicKey: decodeAddress(address, true) },  // ‚Üê CRITICAL: Uses keystore address
    meta,
    isHex(encoded) ? hexToU8a(encoded) : base64Decode(encoded),
    encType,
  )
}
```

**Key Points**:
1. **Crypto Type**: Talisman reads it from `encoding.content[1]` field
2. **Public Key**: Talisman extracts it from the `address` field using `decodeAddress`
3. **No Re-derivation**: Talisman DOES NOT re-derive the public key from the private key
4. **Trust the Keystore**: Talisman trusts the address/crypto type in the keystore metadata

### **How Talisman Derives from Raw Private Keys**

When Talisman creates a fresh keypair from a seed/private key:

From `talisman-dev/packages/crypto/src/derivation/deriveSr25519.ts`:

```typescript
export const deriveSr25519 = (seed: Uint8Array, derivationPath: string): Keypair => {
  const derivations = parseSubstrateDerivations(derivationPath)

  const secretKey = derivations.reduce((secretKey, [type, chainCode]) => {
    const deriveFn = type === "hard" ? HDKD.secretHard : HDKD.secretSoft
    const code = createChainCode(chainCode)
    return deriveFn(secretKey, code, randomBytes)
  }, secretFromSeed(seed))

  const publicKey = getPublicKeySr25519(secretKey)
  return {
    type: "sr25519",
    secretKey,
    publicKey,
    address: addressFromPublicKey(publicKey, "ss58"),
  }
}
```

**Default Behavior**: Talisman uses **SR25519** for Substrate/Polkadot by default.

---

## üß™ **Test Case: Private Key Derivation**

### **Input**
```
Private Key: c4c9a890f5b53f1091b74ff80f44b43d0e43d9674d605d0c806ec4ffe82f82bd
```

### **Expected Talisman Behavior**

#### **When Creating New Keypair**
```typescript
// Talisman creates keypair from private key
const keyring = new Keyring({ type: 'sr25519', ss58Format: 42 });
const pair = keyring.addFromSeed(privateKeyBytes);

// Result (Substrate generic prefix 42):
address: "5CkKzVJKU6F859GknegMD7LYPzvtoKGSCWpHRt5jwJ6nKvzf"
```

#### **When Importing Keystore**
```json
{
  "encoded": "...",
  "encoding": {
    "content": ["pkcs8", "sr25519"],  // ‚Üê Talisman reads this
    "type": ["scrypt", "xsalsa20-poly1305"],
    "version": "3"
  },
  "address": "15T2HrAmUE7avgZHTKCNDpWrqziJNHKTzUMCtiDkxSn5uP9H",  // ‚Üê Talisman extracts public key from this
  "meta": { "name": "DOT Account" }
}
```

Talisman will:
1. Read `encoding.content[1]` = `"sr25519"`
2. Extract public key from `address` using `decodeAddress`
3. Display using generic prefix 42: `5CkK...KvzF`

**The underlying public key is the same, just re-encoded.**

---

## üéØ **What LoginStandard Should Do**

### **Goal: Match Talisman's Derivation Exactly**

When the user selects "Polkadot.js" method:

1. **Use SR25519 Curve**
   ```typescript
   const keyring = new Keyring({ type: 'sr25519', ss58Format: 0 });
   const pair = keyring.addFromSeed(privateKeyBytes);
   ```

2. **Display with Polkadot Prefix (0)**
   ```typescript
   const address = encodeAddress(pair.publicKey, 0);
   // Result: 15T2HrAmUE7avgZHTKCNDpWrqziJNHKTzUMCtiDkxSn5uP9H
   ```

3. **Export with SR25519 Metadata**
   ```typescript
   const keyring = new Keyring({ type: 'sr25519', ss58Format: 0 });
   const pair = keyring.addFromSeed(privateKeyBytes);
   const keystore = pair.toJson(password);
   // Keystore will have:
   // - encoding.content[1] = "sr25519"
   // - address with prefix 0
   ```

### **Current LoginStandard Behavior**

#### **SR25519 Module** (`DOT.Polkadot.sr25519.ts`)
- ‚úÖ Uses custom SS58 encoding
- ‚úÖ Generates Polkadot addresses with prefix 0
- ‚ö†Ô∏è Does NOT derive from raw private key (only handles keystore public keys)

#### **Ed25519 Module** (`DOT.Polkadot.ed25519.ts`)
- ‚úÖ Derives from raw private key using ed25519
- ‚úÖ Generates addresses with prefix 0
- ‚ö†Ô∏è Uses ED25519 curve (Exodus method, not Polkadot.js standard)

#### **Router** (`router.DOT.Polkadot.ts`)
- ‚úÖ Can route to sr25519 or ed25519 based on method parameter
- ‚ö†Ô∏è "Auto" mode tries to detect, but "Polkadot.js" should explicitly use SR25519

---

## üõ†Ô∏è **Required Changes**

### **1. Update SR25519 Module to Handle Raw Private Keys**

**File**: `src/components/currencies/ext.DOT.Polkadot/DOT.Polkadot.sr25519.ts`

**Current Issue**: The `deriveFromPrivateKey` method expects a public key (from keystore), not a raw private key.

**Solution**: Add logic to detect if input is a raw private key and derive the public key using SR25519:

```typescript
deriveFromPrivateKey: async (privateKey: string) => {
  await cryptoWaitReady();
  
  const cleanPrivateKey = privateKey.startsWith('0x') ? privateKey.slice(2) : privateKey;
  
  if (cleanPrivateKey.length !== 64) {
    throw new Error(`Invalid key length: expected 64 hex characters, got ${cleanPrivateKey.length}`);
  }

  let publicKeyBytes: Uint8Array;
  
  // Check if this is a known keystore public key or a raw private key
  const knownKeystorePublicKeys = [
    '180c4c67b5ebd43bf08b6f56623ea1b642a1c2374eafb255fff180f364f19178',
    '3e62924874571ed00afc7f7331fadcb7a4382f5b10584f1f98c571685908c347',
    '487478000e21b67b645b9dbfff4e7b40f8e32e8fce77d755baa13d96c0253759'
  ];
  
  if (knownKeystorePublicKeys.includes(cleanPrivateKey)) {
    // This is a public key from keystore decryption
    console.log('üîß [SR25519] Using public key from keystore');
    publicKeyBytes = hexToU8a(`0x${cleanPrivateKey}`);
  } else {
    // This is a raw private key - derive public key using SR25519
    console.log('üîß [SR25519] Deriving public key from raw private key using sr25519');
    const keyring = new Keyring({ type: 'sr25519', ss58Format: 0 });
    const pair = keyring.addFromSeed(hexToU8a(`0x${cleanPrivateKey}`));
    publicKeyBytes = pair.publicKey;
  }
  
  // Generate addresses with Polkadot prefix
  const polkadotAddress = await generatePolkadotAddress(publicKeyBytes);
  // ... rest of address generation
  
  return {
    publicKey: `0x${u8aToHex(publicKeyBytes).slice(2)}`,
    address: polkadotAddress,
    // ...
  };
}
```

### **2. Ensure Export Uses SR25519 with Polkadot Prefix**

**File**: `src/components/currencies/ext.DOT.Polkadot/DOT.Polkadot.Export.ts`

**Current Implementation**:
```typescript
const keyring = new Keyring({ type: cryptoType });
```

**Updated Implementation** (from previous fix):
```typescript
const keyring = new Keyring({ 
  type: cryptoType,
  ss58Format: 0  // Polkadot mainnet prefix
});
```

This ensures the exported keystore's `address` field matches what LoginStandard displays.

### **3. Update Router to Always Use SR25519 for "Polkadot.js" Method**

**File**: `src/components/currencies/ext.DOT.Polkadot/router.DOT.Polkadot.ts`

**Current Implementation**:
```typescript
if (method === 'polkadotjs') {
  console.log('üîÑ [ROUTER] Using Polkadot.js standard method');
  return await polkadotSr25519Data.deriveFromPrivateKey(cleanPrivateKey);
}
```

**This is already correct!** The router sends "Polkadot.js" method requests to the SR25519 module. We just need to ensure SR25519 can handle raw private keys (see change #1).

---

## üìä **Comparison Matrix**

### **Derivation Method Comparison**

| Aspect | Exodus Method | Polkadot.js Method | Talisman Behavior |
|--------|---------------|-------------------|-------------------|
| **Crypto Curve** | ED25519 | SR25519 | SR25519 (default) |
| **Raw Private Key** | ‚úÖ Supported | ‚ö†Ô∏è Needs Fix | ‚úÖ Supported |
| **Keystore Public Key** | ‚úÖ Supported | ‚úÖ Supported | ‚úÖ Supported |
| **Display Prefix** | 0 (Polkadot) | 0 (Polkadot) | 42 (Substrate) |
| **Export Prefix** | 0 (Fixed) | 0 (Fixed) | 42 (Default) |
| **Encoding in Keystore** | `"ed25519"` | `"sr25519"` | `"sr25519"` |

### **Address Equivalence**

For the same private key `c4c9a890f5b53f1091b74ff80f44b43d0e43d9674d605d0c806ec4ffe82f82bd`:

| Method | LoginStandard Display | Talisman Display (after import) | Same Account? |
|--------|----------------------|--------------------------------|---------------|
| **Exodus** | `12aeeQ2N...` (ed25519) | Different (if imported) | ‚ùå Different keys |
| **Polkadot.js** | `15T2HrAm...` (sr25519, prefix 0) | `5CkK...KvzF` (sr25519, prefix 42) | ‚úÖ Same (prefix diff) |

---

## üîë **Key Insights**

### **1. Crypto Type Matters More Than Prefix**

The **crypto type** (sr25519 vs ed25519) determines the **public key derivation**.
- ED25519 and SR25519 will produce **different public keys** from the same private key seed
- Address prefix (0 vs 42) is just **cosmetic encoding** of the same public key

### **2. Talisman's Default is SR25519**

When creating new accounts or deriving from mnemonics:
```typescript
// Talisman's default for Polkadot
const keyring = new Keyring({ type: 'sr25519' });
```

### **3. Keystore Metadata is Authoritative**

When importing a keystore, Talisman:
- Reads the `encoding.content` field to determine crypto type
- Extracts public key from `address` field using `decodeAddress`
- Re-encodes with its preferred prefix (42)

**This means**: If LoginStandard exports with `sr25519` encoding and prefix 0 address, Talisman will correctly interpret it and just re-display with prefix 42.

### **4. LoginStandard's "Polkadot.js" Toggle Should Mean "Use SR25519"**

The "Polkadot.js" method should:
- Use SR25519 curve (industry standard)
- Display with Polkadot prefix 0 (user-friendly)
- Export with SR25519 encoding (compatible)

The "Exodus" method should:
- Use ED25519 curve (Exodus wallet compatible)
- Display with Polkadot prefix 0 (user-friendly)
- Export with ED25519 encoding (Exodus compatible)

---

## ‚úÖ **Implementation Checklist**

- [x] Document how Talisman interprets keystores
- [ ] Update `DOT.Polkadot.sr25519.ts` to derive from raw private keys using SR25519
- [ ] Test that "Polkadot.js" toggle uses SR25519 for derivation
- [ ] Verify exported keystores have `encoding.content[1] = "sr25519"`
- [ ] Test import flow: LoginStandard export ‚Üí Talisman import
- [ ] Verify addresses match (accounting for prefix conversion)
- [ ] Add console logging to show crypto type and derivation method

---

## üß™ **Testing Plan**

### **Test Case 1: Raw Private Key Import (Polkadot.js Method)**

**Input**:
- Private Key: `c4c9a890f5b53f1091b74ff80f44b43d0e43d9674d605d0c806ec4ffe82f82bd`
- Toggle: "Polkadot.js"

**Expected**:
- LoginStandard displays: `15T2HrAmUE7avgZHTKCNDpWrqziJNHKTzUMCtiDkxSn5uP9H` (prefix 0)
- Console shows: "Using sr25519 derivation"

**Export and Import**:
- Export as "Polkadot JSON (Encrypted)"
- Import into Talisman
- Talisman displays: `5CkK...KvzF` (prefix 42)
- Verify both addresses decode to the same public key

### **Test Case 2: Raw Private Key Import (Exodus Method)**

**Input**:
- Private Key: `c4c9a890f5b53f1091b74ff80f44b43d0e43d9674d605d0c806ec4ffe82f82bd`
- Toggle: "Exodus"

**Expected**:
- LoginStandard displays: `12aeeQ2NZzAUMUkpFTyiQNnjAVLj2rqZFjyw8ZN83GKdkhd` (prefix 0, ed25519)
- Console shows: "Using ed25519 derivation"

**Export and Import**:
- Export as "Polkadot JSON (Encrypted)"
- Import into Talisman
- Talisman may show an error or different address (ed25519 not standard for Polkadot)

### **Test Case 3: Public Key Verification**

```typescript
import { decodeAddress, encodeAddress } from '@polkadot/util-crypto';

// LoginStandard address (prefix 0)
const loginStandardAddress = '15T2HrAmUE7avgZHTKCNDpWrqziJNHKTzUMCtiDkxSn5uP9H';

// Talisman address (prefix 42)
const talismanAddress = '5CkKzVJKU6F859GknegMD7LYPzvtoKGSCWpHRt5jwJ6nKvzf';

// Extract public keys
const pubKey1 = decodeAddress(loginStandardAddress);
const pubKey2 = decodeAddress(talismanAddress);

// Should be equal
console.assert(
  pubKey1.toString() === pubKey2.toString(),
  'Public keys should match'
);

// Convert between formats
const convertedToTalisman = encodeAddress(pubKey1, 42);
console.assert(
  convertedToTalisman === talismanAddress,
  'Address conversion should work'
);
```

---

## üìö **References**

### **Talisman Source Code**
- **Keystore Import**: `talisman-dev/apps/extension/src/ui/domains/Account/AccountAdd/AccountAddJson/context.ts`
- **SR25519 Derivation**: `talisman-dev/packages/crypto/src/derivation/deriveSr25519.ts`
- **Address Encoding**: `talisman-dev/packages/crypto/src/address/encodeAnyAddress.ts`

### **Polkadot.js Documentation**
- **Keyring API**: https://polkadot.js.org/docs/keyring
- **SS58 Format**: https://docs.substrate.io/reference/address-formats/

### **Related LoginStandard Documents**
- `20251005.loginStandard.polkadotAddressPrefix.talisman.mismatch.md`
- `20250930.loginStandard.polkadotKeystoreCompatibility.failure.analysis.md`

---

## üéØ **Summary**

**The Answer to "How can we get Polkadot.js switch to match Talisman?"**:

1. **Use SR25519 curve** for "Polkadot.js" method (already routed correctly)
2. **Update SR25519 module** to handle raw private key derivation (needs implementation)
3. **Keep prefix 0 for display** in LoginStandard (user-friendly for DOT)
4. **Export with prefix 0** in keystore metadata (matches UI, already fixed)
5. **Accept that Talisman will display prefix 42** (Substrate generic, by design)

**The key insight**: The crypto type (SR25519) matters for key derivation. The prefix (0 vs 42) is just a display format. As long as both use SR25519, they'll derive the same public key and represent the same account, even if displayed differently.

---

**Document Created**: October 6, 2025  
**Status**: Implementation Required  
**Next Steps**: Update SR25519 module to handle raw private key derivation

