# Sparkplate Finding: Index Composite Cross-Contamination Issue

**Date:** January 17, 2026  
**Component:** `src/components/pageTabs/cryptocurrency/Indices.vue`  
**Severity:** Medium  
**Status:** Resolved  

---

## Issue Summary

Cryptocurrency indices were experiencing cross-contamination, where currencies from one index (e.g., Komodo/KMD) were appearing in unrelated indices such as:
- NY Exchange Offerings - bitFlyer
- NY Exchange Offerings - PayPal/Venmo  
- Greenery V1

This occurred despite the data arrays being correctly isolated in their respective source files.

---

## Error Manifestation

### Symptoms
1. **Cross-contamination**: Currencies like Komodo (KMD) appeared in multiple unrelated indices
2. **Inconsistent display**: Switching between indices showed currencies that shouldn't exist in those lists
3. **Data integrity violation**: Each index should only display its own currencies

### Expected Behavior
- bitFlyer (NY) should show only: BCH, BTC, ETC, ETH, LTC (5 currencies)
- PayPal/Venmo (NY) should show only: BCH, BTC, ETH, LINK, LTC, PYUSD, SOL (7 currencies)
- Greenery V1 should show only its specific 30+ currencies
- KMD should ONLY appear in: Proof of Work, Proof of Stake, and Random List (UCID)

### Actual Behavior
KMD (Komodo) appeared across multiple indices where it shouldn't exist.

---

## Root Cause Analysis

### Primary Cause: Vue Component Reuse via Key Collision

The issue stemmed from Vue's virtual DOM optimization strategy. The component was using a non-unique key for table rows:

```vue
<tr
  v-for="(currency, index) in filteredCurrencies"
  :key="currency.symbol || currency.tickerSymbol"
  class="hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors"
>
```

**Problem:** When switching between indices, if a currency symbol (e.g., "KMD") existed in multiple source arrays, Vue would reuse the same DOM element because the key was identical. This caused:
1. **DOM element persistence**: Vue kept the same DOM node when it should have created a new one
2. **Stale data display**: Old currency data remained visible when switching indices
3. **Visual cross-contamination**: Users saw currencies from previously selected indices

### Secondary Cause: Shallow Array Copying

The computed property used shallow copying:

```typescript
const dataArray = Array.isArray(index.data) ? [...index.data] : []
```

While this created a new array, it shared object references with the source data. If any mutations occurred (even from Vue's reactivity system), they could affect multiple views.

---

## Technical Deep Dive

### Vue's Key-Based Recycling

Vue uses the `:key` attribute to track component identity. When keys match across renders:
1. Vue assumes it's the same logical entity
2. The existing DOM node is reused
3. Only changed attributes/content are updated
4. This optimization normally improves performance

However, when the same key represents DIFFERENT logical entities across different contexts (indices), Vue incorrectly reuses components, leading to stale data display.

### Shared Reference Issue

JavaScript objects are passed by reference. Even with array spreading (`[...]`), the inner objects are still references:

```typescript
const original = [{ symbol: 'KMD' }, { symbol: 'BTC' }]
const copy = [...original]
copy[0] === original[0] // true - same object reference!
```

This means:
- Multiple indices referencing the same currency data share the same object
- Vue's reactivity system tracks these shared objects
- Changes or reactivity side effects can leak across indices

---

## Solution Implementation

### 1. Unique Composite Keys

Updated the v-for key to include both the index ID and position:

```vue
<tr
  v-for="(currency, index) in filteredCurrencies"
  :key="`${selectedIndex}-${index}-${currency.symbol || currency.tickerSymbol || currency.ticker}`"
  class="hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors"
>
```

**Benefits:**
- Each row has a globally unique key across all indices
- Vue creates fresh DOM elements when switching indices
- No component reuse across different index selections
- Eliminates DOM-level cross-contamination

### 2. Deep Cloning for Data Isolation

Implemented deep cloning to ensure complete object isolation:

```typescript
const filteredCurrencies = computed(() => {
  const index = availableIndices.find(idx => idx.id === selectedIndex.value)
  if (!index || !index.data) return []
  
  // Create a deep copy to ensure complete isolation between indices
  // This prevents any shared references or Vue reactivity issues
  const dataArray = Array.isArray(index.data) 
    ? JSON.parse(JSON.stringify(index.data)) 
    : []
  
  // Handle different currency item structures
  return dataArray.map((item: any) => {
    if ('tickerSymbol' in item && !('symbol' in item)) {
      return { ...item, symbol: item.tickerSymbol }
    }
    if ('ticker' in item && !('symbol' in item)) {
      return { ...item, symbol: item.ticker }
    }
    return item
  })
})
```

**Benefits:**
- Complete object isolation - no shared references
- Each index gets its own copy of all data
- Mutations cannot propagate between indices
- Vue's reactivity tracks separate objects per index

---

## Trade-offs and Considerations

### Performance Impact

**Deep Cloning:**
- **Cost**: `JSON.parse(JSON.stringify())` is slower than shallow copying
- **Overhead**: Proportional to data size (each index has 5-2000+ items)
- **Mitigation**: 
  - Computed properties are cached
  - Only recalculates when `selectedIndex` changes
  - User action frequency is low (selecting different indices)
  - Data sets are relatively small (< 1MB even for largest indices)

**Verdict**: The performance cost is acceptable given:
1. Human interaction speed (users don't rapidly switch indices)
2. Cached computation results
3. Correctness is more important than micro-optimizations

### Alternative Solutions Considered

1. **Immutable Data Structures**: 
   - Would prevent mutations entirely
   - Requires library dependency (Immutable.js, Immer)
   - Adds complexity to the codebase
   - Overkill for this use case

2. **Vue's `shallowRef`**:
   - Could reduce reactivity overhead
   - Doesn't solve the key collision issue
   - Partial solution only

3. **Separate Components per Index**:
   - Complete isolation guaranteed
   - Massive code duplication (20+ nearly identical components)
   - Maintenance nightmare
   - Not scalable

4. **Manual Cache Invalidation**:
   - Force Vue to recreate components on index change
   - Hacky, not idiomatic Vue
   - Doesn't address root cause

**Selected Solution**: Composite keys + deep cloning provides the best balance of correctness, maintainability, and performance.

---

## Verification

### Test Cases

1. **Cross-Index Currency Isolation**:
   - Select "Proof of Work" → Verify KMD appears
   - Select "bitFlyer (NY)" → Verify KMD does NOT appear
   - Select "Proof of Stake" → Verify KMD appears again
   - Select "PayPal/Venmo (NY)" → Verify KMD does NOT appear

2. **Data Integrity**:
   - Each index displays only its designated currencies
   - Currency counts match source file lengths
   - No phantom currencies appear

3. **Switching Performance**:
   - Rapid index switching shows correct data
   - No visual artifacts or stale data
   - Smooth transitions between indices

---

## Prevention Measures

### Code Review Checklist
- [ ] All v-for loops use unique, context-aware keys
- [ ] Shared data sources are properly cloned when used in multiple contexts
- [ ] Computed properties don't share object references
- [ ] Vue component keys incorporate parent context when necessary

### Documentation
- Added comments explaining the deep clone necessity
- Documented the key structure and why it includes `selectedIndex`

### Future Considerations
- Consider migrating to a state management solution (Pinia/Vuex) for large-scale data
- Implement automated tests that verify index isolation
- Add runtime assertions in development mode to detect cross-contamination

---

## Related Issues

- **libsodium ESM Import Resolution** (01162026): Demonstrated importance of proper module isolation
- **Missing Crypto Icons in Production** (10202025): Related to asset path resolution

---

## References

- Vue.js Documentation: [List Rendering - Key](https://vuejs.org/guide/essentials/list.html#maintaining-state-with-key)
- Vue.js Documentation: [Reactivity Fundamentals](https://vuejs.org/guide/essentials/reactivity-fundamentals.html)
- JavaScript Deep Clone: [MDN - structuredClone](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone) (Note: Using JSON method for broader compatibility)

---

## Conclusion

The cross-contamination issue was caused by Vue's component recycling mechanism combined with non-unique keys. The solution requires:
1. Composite keys that include parent context (selectedIndex)
2. Deep cloning to ensure object isolation

This pattern should be applied to all similar list-rendering scenarios where:
- Multiple data sources share items with identical identifiers
- Data is switched based on user selection
- Visual corruption from stale data is unacceptable

**Lesson Learned**: When rendering lists from multiple switchable data sources, always use composite keys that include the data source identifier, and ensure complete object isolation through deep cloning when necessary.

