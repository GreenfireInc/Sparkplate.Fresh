# Seed Phrase Export Performance: Redundant GPG Fingerprint Generation

**Date:** February 15, 2026  
**Component:** `MnemonicSeedPhrase.vue`, `filenameStructureAndContent.seed.text.ts`, `filenameStructureAndContent.seed.visual.ts`  
**Topic:** Export Performance Optimization via GPG Fingerprint Caching  
**Status:** Resolved

---

## Overview

When clicking any download option (JSON, TXT, CSV, PNG, PDF) from the seed phrase export dropdown in `MnemonicSeedPhrase.vue`, the UI would freeze for several seconds before the file download dialog appeared. Investigation revealed that expensive cryptographic operations were being redundantly re-computed on every export, despite the results already being available in component state.

---

## Root Cause

### The Watcher Already Computes the Fingerprint

The component has a `watch` on the `mnemonic` ref that generates the BIP32 Root GPG Key Fingerprint whenever the seed phrase changes:

```typescript
watch(mnemonic, async (newMnemonic) => {
  // ...validation...
  const result = await generateGPGFromRootExtendedPrivateKey(newMnemonic)
  rootGPGFingerprint.value = result.gpgFingerprint
})
```

This computed fingerprint is stored in `rootGPGFingerprint` and displayed in the UI. However, the export functions **did not accept this precomputed value** — they each regenerated it from scratch.

### What Each Export Was Doing

| Format | Redundant Operations | Approximate Cost |
|--------|---------------------|------------------|
| **JSON** | `generateGPGFromRootExtendedPrivateKey()` — BIP39 seed → BIP32 root → GPG keypair | 1 full GPG generation |
| **TXT** | Same as JSON | 1 full GPG generation |
| **CSV** | Same as JSON | 1 full GPG generation |
| **PNG** | GPG generation ×1 inside `captureSeedPhraseCanvas()` + `generateAddressesFromMnemonic()` (8 currencies, each with GPG) | ~9 GPG generations + 8 address derivations |
| **PDF** | GPG generation ×2 (canvas + text overlay) + `generateAddressesFromMnemonic()` ×2 | ~18 GPG generations + 16 address derivations |

### The Expensive Function Chain

```
generateGPGFromRootExtendedPrivateKey(mnemonic)
  └── bip39.mnemonicToSeed(mnemonic)          // PBKDF2 with 2048 iterations
  └── bip32.fromSeed(seed)                     // BIP32 root key derivation
  └── generateDeterministicGPGKey(xprv, 'ROOT') // OpenPGP key generation
```

Each call to `generateGPGFromRootExtendedPrivateKey` involves PBKDF2 key stretching, BIP32 hierarchical derivation, and full OpenPGP key pair generation — operations that are intentionally computationally expensive for security purposes.

For PNG/PDF exports, `generateAddressesFromMnemonic` additionally derives keys for **8 cryptocurrencies** (BTC, LTC, DOGE, ETH, TRX, SOL, XTZ, LUNC), each with its own GPG key generation, compounding the delay.

---

## Solution

### 1. Added `precomputedGPGFingerprint` Parameter to Export Functions

All export functions were updated to accept an optional precomputed fingerprint. When provided, the expensive GPG generation is skipped entirely.

**Text exports** (`filenameStructureAndContent.seed.text.ts`):

```typescript
export async function generateSeedJSONContent(
  mnemonicSeedPhrase: string,
  customDate?: Date,
  precomputedGPGFingerprint?: string  // NEW
): Promise<string> {
  // ...
  let gpgFingerprint = "";
  if (precomputedGPGFingerprint) {
    gpgFingerprint = precomputedGPGFingerprint;  // Skip generation
  } else {
    // Fallback: generate from scratch (backward compatible)
    const gpgResult = await generateGPGFromRootExtendedPrivateKey(mnemonicSeedPhrase);
    gpgFingerprint = gpgResult.gpgFingerprint;
  }
  // ...
}
```

The same pattern was applied to `generateSeedTXTContent` and `generateSeedCSVContent`.

**Visual exports** (`filenameStructureAndContent.seed.visual.ts`):

```typescript
export async function captureSeedPhraseCanvas(
  mnemonicSeedPhrase: string,
  opts?: { scale?: number; forPDF?: boolean; precomputedGPGFingerprint?: string }  // NEW
): Promise<HTMLCanvasElement> {
  // ...
  const precomputedGPGFingerprint = opts?.precomputedGPGFingerprint;
  // Uses precomputed value if available, falls back to generation
}

export async function exportSeedPhraseAsPNG(
  mnemonicSeedPhrase: string, 
  precomputedGPGFingerprint?: string  // NEW
) { /* passes through to captureSeedPhraseCanvas */ }

export async function exportSeedPhraseAsPDF(
  mnemonicSeedPhrase: string, 
  precomputedGPGFingerprint?: string  // NEW
) { /* passes through to canvas + PDF text overlay */ }
```

### 2. Component Passes Cached Fingerprint on Download

```typescript
const downloadSeedPhrase = async (format: 'json' | 'txt' | 'csv' | 'png' | 'pdf') => {
  if (!mnemonic.value) return
  
  const date = new Date()
  // Reuse the already-computed GPG fingerprint to avoid expensive re-generation
  const cachedFingerprint = rootGPGFingerprint.value || undefined

  if (format === 'png') {
    await exportSeedPhraseAsPNG(mnemonic.value, cachedFingerprint)
    // ...
  }

  // Same pattern for all other formats...
  case 'json':
    content = await generateSeedJSONContent(mnemonic.value, date, cachedFingerprint)
    break
}
```

---

## Files Modified

| File | Changes |
|------|---------|
| `src/lib/cores/exportStandard/currencies/filenameStructureAndContent.seed.text.ts` | Added `precomputedGPGFingerprint?` param to `generateSeedJSONContent`, `generateSeedTXTContent`, `generateSeedCSVContent` |
| `src/lib/cores/exportStandard/currencies/filenameStructureAndContent.seed.visual.ts` | Added `precomputedGPGFingerprint?` param to `captureSeedPhraseCanvas`, `exportSeedPhraseAsPNG`, `exportSeedPhraseAsPDF`; eliminated redundant GPG call in PDF text overlay |
| `src/components/pageTabs/cryptocurrency/MnemonicSeedPhrase.vue` | Updated `downloadSeedPhrase` to pass `rootGPGFingerprint.value` to all export functions |

---

## Performance Impact

### JSON / TXT / CSV Exports
- **Before:** ~2-5 seconds (full GPG key generation on each click)
- **After:** Near-instant (string formatting only, no crypto)

### PNG / PDF Exports
- **Before:** ~10-30 seconds (GPG generation ×2 + address derivation for 8 currencies ×2)
- **After:** Reduced by eliminating redundant GPG calls; `generateAddressesFromMnemonic` still runs once per export (unavoidable without further caching)

---

## Design Considerations

### Backward Compatibility
All parameters are optional. If `precomputedGPGFingerprint` is not provided, the functions fall back to generating the fingerprint from scratch. This ensures the export functions remain usable as standalone utilities outside of the component context.

### Cache Validity
The `watch` on `mnemonic` guarantees that `rootGPGFingerprint` is always in sync with the current seed phrase. Since GPG generation is deterministic (same mnemonic always produces the same fingerprint), there is no risk of stale cache values — a given mnemonic will always map to the same fingerprint.

### Remaining Optimization Opportunity
The `generateAddressesFromMnemonic()` call in PNG/PDF exports still derives keys for 8 currencies on each export. A future optimization could pre-compute and cache these addresses when the mnemonic changes (similar to how the GPG fingerprint is cached), further reducing PNG/PDF export times.

---

## Key Takeaway

When expensive computations are already performed reactively (via watchers or computed properties), always check whether downstream consumers can reuse those results rather than recomputing them. In this case, a single GPG fingerprint was being generated up to **18 times** per PDF export when it only needed to be generated **once** per seed phrase change.

